<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://maplestory.work/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://maplestory.work"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2019-07-15- Kotlin 学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/2019-07-15- Kotlin 学习记录/" class="article-date">
  <time datetime="2019-07-14T16:00:00.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/2019-07-15- Kotlin 学习记录/">Kotlin 学习记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b> Kotlin 学习记录 </b></h2></center><br>

<pre><code>本文只记录重要的或者与C/C++、Java 出入较大的内容，或者我未习得的知识点</code></pre><h2 id="Kotlin-变、常量用法"><a href="#Kotlin-变、常量用法" class="headerlink" title="Kotlin 变、常量用法"></a>Kotlin 变、常量用法</h2><ol>
<li><p>在类中定义变量必须初始化，暂时不能初始化的可用<strong>lateinit</strong>[后期初始化]关键字声明</p>
</li>
<li><p><strong>lateinit</strong>只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）</p>
</li>
<li><p>延后初始化。只能用于只读变量。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个延迟初始化的字符串数组变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mTitles : Array&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">arrayOf(</span><br><span class="line">        ctx.getString(R.string.tab_title_android),</span><br><span class="line">        ctx.getString(R.string.tab_title_ios),</span><br><span class="line">        ctx.getString(R.string.tab_title_h5)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个延迟初始化的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mStr : String <span class="keyword">by</span> lazy&#123;</span><br><span class="line"><span class="string">"我是延迟初始化字符串变量"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>val 不是常量，是不可修改的变量。常量为 const val 且 const 不能用于修饰var</p>
</li>
<li><p>常量声明的三种正确方式</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 顶层声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> NUM_A : String = <span class="string">"顶层声明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在object修饰的类中</span></span><br><span class="line"><span class="keyword">object</span> TestConst&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> NUM_B = <span class="string">"object修饰的类中"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 伴生对象中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NUM_C = <span class="string">"伴生对象中声明"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"NUM_A =&gt; <span class="variable">$NUM_A</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_B =&gt; <span class="subst">$&#123;TestConst.NUM_B&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_C =&gt; <span class="subst">$&#123;TestClass.NUM_C&#125;</span>"</span>)</span><br><span class="line">&#125;常量声明的三种正确方式</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>Kotlin当中不支持8进制</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num16 = <span class="number">0x0F</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0b11110001</span></span><br><span class="line"><span class="keyword">var</span> num10 = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Kotlin中可以通过下划线作数值中的逗号</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line">println(<span class="string">"var oneMillion = 1_000_000 =&gt; var oneMillion = <span class="variable">$oneMillion</span>"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>数值比较：== 比较值，===比较内存中的地址</p>
</li>
<li><p>位运算大有不同：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operaNum = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shlnum = operaNum shl(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> shrnum = operaNum shr(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> ushrnum = operaNum ushr(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">" shlOperaNum =&gt; <span class="variable">$shlnum</span> \n"</span> +</span><br><span class="line">        <span class="string">" shrOperaNum =&gt; <span class="variable">$shrnum</span> \n"</span> +</span><br><span class="line">        <span class="string">" ushrOperaNum =&gt; <span class="variable">$ushrnum</span> \n "</span> )</span><br></pre></td></tr></table></figure>

<p>​    <code>Kotlin</code>中对于按位操作，和Java是有很大的差别的。<code>Kotlin</code>中没有特殊的字符，但是只能命名为可以以中缀形式调用的函数，下列是按位操作的完整列表(仅适用于整形（<code>Int</code>）和长整形（<code>Long</code>）)：</p>
<blockquote>
<ul>
<li><p><code>shl(bits)</code> =&gt; 有符号向左移 (类似<code>Java</code>的<code>&lt;&lt;</code>)</p>
</li>
<li><p><code>shr(bits)</code> =&gt; 有符号向右移 (类似<code>Java</code>的<code>&gt;&gt;</code>)</p>
</li>
<li><p><code>ushr(bits)</code> =&gt; 无符号向右移 (类似<code>Java</code>的<code>&gt;&gt;&gt;</code>)</p>
</li>
<li><p><code>and(bits)</code> =&gt; 位运算符 <code>and</code> (同<code>Java</code>中的按位与)</p>
</li>
<li><p><code>or(bits)</code> =&gt; 位运算符 <code>or</code> (同<code>Java</code>中的按位或)</p>
</li>
<li><p><code>xor(bits)</code> =&gt; 位运算符 <code>xor</code> (同<code>Java</code>中的按位异或)</p>
</li>
<li><p><code>inv()</code> =&gt; 位运算符 按位取反 (同<code>Java</code>中的按位取反)</p>
</li>
</ul>
</blockquote>
<ol start="5">
<li>数组分 <code>arrayOf()</code>, <code>arrayOfNulls()</code>, <code>Array()</code>, <code>原始类型数组</code></li>
</ol>
<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><ol>
<li><code>IF</code></li>
</ol>
<p>​       需要注意，Kotlin中没有三元运算符 <code>:?</code>, 因为<code>if</code>表达式会有返回值，当条件内逻辑为代码段时，则选择最后一句的值作为返回值。</p>
<ol start="2">
<li><code>FOR</code></li>
</ol>
<p>​       Kotlin中不再有 <code>for(int i=0;i&lt;n;++i)</code> 这种语法。</p>
<blockquote>
<ul>
<li>关键字 until</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">5</span>)&#123;</span><br><span class="line">&gt; print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>) <span class="comment">//until[0,5)</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>关键词downTo</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">15</span> downTo <span class="number">0</span>)&#123;</span><br><span class="line">&gt; 	print(<span class="string">"i=&gt; <span class="variable">$i</span> \t"</span>) <span class="comment">//downTo[15-&gt;0]</span></span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>关键符号“..”</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(<span class="string">"使用 符号`..`的打印结果\n"</span>)</span><br><span class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">20</span> .. <span class="number">25</span>)&#123;</span><br><span class="line">&gt;   print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; println() <span class="comment">//输出结果为 	i=&gt;20 i=&gt;21 i=&gt;22 i=&gt;23 i=&gt;24 i=&gt;25	</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>设置步长</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">10</span> until <span class="number">16</span> step <span class="number">2</span>)&#123;</span><br><span class="line">&gt;   print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)  <span class="comment">//输出10，12，14</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>迭代</li>
</ul>
<blockquote>
<p>提供一个迭代器来遍历任何东西；数组被编译为一个基于索引的循环，<strong>他不会创建一个迭代器对象</strong></p>
</blockquote>
<ul>
<li><p>遍历字符串</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="string">"abcdefg"</span>)&#123;</span><br><span class="line">&gt;   	print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>遍历数组</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">var</span> arrayListOne = arrayOf(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>)</span><br><span class="line">&gt;    <span class="keyword">for</span> (i <span class="keyword">in</span> arrayListOne)&#123;</span><br><span class="line">&gt;        print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用indices遍历数组</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> arrayListTwo = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt;  <span class="keyword">for</span> (i <span class="keyword">in</span> arrayListTwo.indices)&#123;</span><br><span class="line">&gt; 	println(<span class="string">"arrayListTwo[<span class="variable">$i</span>] =&gt; "</span> + arrayListTwo[i])</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用withIndex()遍历数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    var arrayListTwo = arrayOf(1,3,5,7,9)</span><br><span class="line">&gt;    for ((index,value) in arrayListTwo.withIndex())&#123;</span><br><span class="line">&gt;        println(&quot;index =&gt; $index \t value =&gt; $value&quot;)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用列表或数组的扩展函数遍历</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">var</span> arrayListThree = arrayOf(<span class="number">2</span>,<span class="string">'a'</span>,<span class="number">3</span>,<span class="literal">false</span>,<span class="number">9</span>)</span><br><span class="line">&gt;   <span class="keyword">var</span> iterator: Iterator&lt;Any&gt; = arrayListThree.iterator()</span><br><span class="line">&gt;    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">&gt;        println(iterator.next())</span><br><span class="line">&gt;    &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>//需要学习 Kotlin中的 it关键字 / Array函数本质 / lamda表达 / 函数定义</p>
</blockquote>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><ol>
<li><p>语法</p>
<p>无参数的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fun1 = &#123;<span class="number">9</span>&#125; <span class="comment">//定义了一个返回了Int的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该定义参照了情况3</span></span><br><span class="line"><span class="comment">//传入一个Lambda来表示的形式参数，该形参为一个无参返回Int的函数</span></span><br><span class="line"><span class="keyword">var</span> fun11 : (()-&gt;(<span class="built_in">Int</span>)) -&gt;<span class="built_in">Int</span> = &#123;initfunc -&gt; initfunc()&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value00 = fun11(fun1)</span><br><span class="line">println(<span class="string">"value00 =&gt; <span class="variable">$value00</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>有参数的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value1 = <span class="number">9</span></span><br><span class="line"><span class="keyword">val</span> fun2:(<span class="built_in">Int</span>,<span class="built_in">Int</span>)-&gt;<span class="built_in">Double</span> = &#123;a,b-&gt; (a-b).toDouble()&#125;</span><br><span class="line"><span class="keyword">var</span> value2 = fun2(value1,<span class="number">3</span>)</span><br><span class="line">println(<span class="string">"value2 =&gt; <span class="variable">$value2</span>"</span>)<span class="comment">//输出：value2 =&gt; 6.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式如下</span></span><br><span class="line"><span class="keyword">var</span> fun3 = &#123;a:<span class="built_in">Int</span>,b:<span class="built_in">Int</span> -&gt; a+b&#125;</span><br><span class="line"><span class="keyword">var</span> value3 = fun3(<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"value3 =&gt; <span class="variable">$value3</span>"</span>)<span class="comment">//输出：value3 =&gt; 9</span></span><br><span class="line"><span class="comment">//3. lambda表达式作为函数中的参数的时候，这里举一个例子：</span></span><br><span class="line"><span class="comment">//  fun test(a : Int, 参数名 : (参数1 ： 类型，参数2 : 类型, ... ) -&gt; 表达式返	 //回类型)&#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个新形式都可以作为value计算的表达式，fun与var功能似乎一样了？NO</span></span><br><span class="line"><span class="comment">//三种形式定义该test函数，fun声明，var声明，匿名函数。</span></span><br><span class="line"><span class="comment">//fun test(a:Int,b:Int,add:(Int,Int)-&gt;Int):Int&#123; return add(a,b)&#125;//是一个函数</span></span><br><span class="line"><span class="comment">//var test: (Int,Int,(Int,Int)-&gt;Int) -&gt; Int = &#123;a,b,add -&gt; add(a,b)&#125;//该变量是lambda变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="title">fun</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,add:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123; <span class="keyword">return</span> add(a,b)&#125; <span class="comment">//是一个函数</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"value4 = <span class="variable">$value4</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>​        <code>lambda</code>表达式总是被大括号括着</p>
<p>​        定义完整的<code>Lambda</code>表达式如上面实例中的语法2，它有其完整的参数类型标注，与表达式返回值。当我们把一些类型标注省略的情况下，就如上面实例中的语法2的另外一种类型。当它推断出的返回值类型不为<code>Unit</code>时，它的返回值即为-&gt;符号后代码段中的最后一个表达式的类型（如同if-else语句块中的返回值一样）</p>
<p>​        当函数的参数仅有一个Lambda表达式的时候可以<strong>省略参数的那个小括号</strong></p>
</li>
<li><p>it</p>
<ul>
<li>it不是关键字</li>
<li>it在高阶函数中的lambda表达式的参数只有一个的时候可以使用<code>it</code>来使用此参数。<code>it</code>可表示<strong>单个参数的隐式名称</strong></li>
</ul>
<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(num1 : <span class="type">Int</span>, bool : (<span class="type">Int</span>) -&gt; <span class="type">Boolean</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">if</span> (bool(num1))&#123; num1 &#125; <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(test(<span class="number">10</span>,&#123;it &gt; <span class="number">5</span>&#125;)) <span class="comment">// &#123;&#125; 代表这是一个Lambda表达式，无&#123;&#125;会使得编译器不认识it</span></span><br><span class="line">println(test(<span class="number">4</span>,&#123;it &gt; <span class="number">5</span>&#125;))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>_</p>
<p>在使用<code>Lambda</code>表达式的时候，可以用下划线表示未使用的参数，表示不处理这个参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf&lt;String,String&gt;(<span class="string">"key1"</span> to <span class="string">"value1"</span>,<span class="string">"key2"</span> to  <span class="string">"value2"</span>,<span class="string">"key3"</span> to  <span class="string">"value3"</span>)</span><br><span class="line"></span><br><span class="line">map.forEach&#123;</span><br><span class="line">    key,value -&gt; println(<span class="string">"<span class="variable">$key</span> '-' <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">map.forEach&#123;</span><br><span class="line">        _,value -&gt; println(<span class="string">" '-' <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>匿名函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test1 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> = x+y; <span class="comment">//单表达式函数可以 = 替换 &#123;&#125;</span></span><br><span class="line"><span class="keyword">val</span> test2 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>= x+y;</span><br><span class="line"><span class="keyword">val</span> test3 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">println(test1(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">println(test2(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">println(test3(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//这是错的，fun的需要返回值为Unit，但你给了个Int</span></span><br><span class="line"><span class="comment">    val test4= fun(x:Int,y:Int) &#123;</span></span><br><span class="line"><span class="comment">        return x+y</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>带接收者的函数字面值</p>
<ol start="6">
<li><p>匿名函数作为接收者类型</p>
<p>匿名函数语法允许直接指定函数字面值的接收者类型，如果你需要使用带接收者的函数类型声明一个变量。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iop = <span class="function"><span class="keyword">fun</span>  <span class="built_in">Int</span>.<span class="params">(other:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> = <span class="keyword">this</span> + other</span><br><span class="line">println(<span class="number">20</span>.iop(<span class="number">2</span>)) <span class="comment">//上面的this指的是左边的20 或者是 上面fun后的第一个Int</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="2">
<li><p>Lambda表达式作为接收者类型</p>
<p>要用Lambda表达式作为接收者类型的前提是**接收着类型可以从上下文中推断出来</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTML</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">body</span><span class="params">()</span></span>&#123;</span><br><span class="line">		println(<span class="string">"This is HTML body"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span>  <span class="title">html</span><span class="params">(<span class="keyword">init</span>: <span class="type">HTML</span>.() -&gt; <span class="type">Unit</span>)</span></span>: HTML&#123;</span><br><span class="line">	<span class="keyword">val</span> html = HTML()</span><br><span class="line">	html.<span class="keyword">init</span>()</span><br><span class="line">	<span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">	body()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="6">
<li><p>闭包</p>
<p>闭包，可以函数中包含函数。</p>
<ul>
<li>携带状态</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">让函数返回一个函数，并携带状态值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test5</span><span class="params">(a:<span class="type">Int</span>)</span></span>:()-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">    println(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        println(<span class="string">"b=&gt; <span class="variable">$b</span>"</span>)</span><br><span class="line">        b++</span><br><span class="line">        <span class="keyword">return</span> b + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = test5(<span class="number">3</span>)</span><br><span class="line">println(t()) <span class="comment">// 每次执行t函数的时候，b变量的值都是保留了上次执行结束的值，</span></span><br><span class="line">			 <span class="comment">// 因此，叫做携带状态值</span></span><br><span class="line">println(t())</span><br><span class="line">println(t())</span><br></pre></td></tr></table></figure>

<ul>
<li>引用外部变量，并改变外部变量的值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">arr.filter &#123; it&lt;<span class="number">7</span> &#125;.forEach&#123;sum += it&#125;</span><br><span class="line"><span class="comment">//arr.filter &#123; it&lt;7 &#125;.forEach (&#123;sum += it&#125;)</span></span><br><span class="line"></span><br><span class="line">println(sum)</span><br></pre></td></tr></table></figure>

<h2 id="可空类型、空安全、非空断言"><a href="#可空类型、空安全、非空断言" class="headerlink" title="可空类型、空安全、非空断言"></a>可空类型、空安全、非空断言</h2><ol>
<li><p>判空的方法，if-else / ?. 判断</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str : String? = <span class="string">"12346"</span></span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">println(str?.length) <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个函数/方法有返回值时，如果方法中的代码使用<code>?.</code>去返回一个值，那么方法的返回值的类型后面也要加上<code>?</code>符号</p>
</li>
<li><p>let操作符</p>
<p>let操作符作用：当使用?.符号时验证时忽略掉null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val arrTest : Array&lt;Int?&gt; = arrayOf(1,2,null,3,null,5,6,null)</span><br><span class="line"></span><br><span class="line">// 传统写法</span><br><span class="line">for (index in arrTest) &#123;</span><br><span class="line">    if (index == null)&#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;index =&gt; $index&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// let写法</span><br><span class="line">for (index in arrTest) &#123;</span><br><span class="line">    index?.let &#123; println(&quot;index =&gt; $it&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    index =&gt; 1</span><br><span class="line">    index =&gt; 2</span><br><span class="line">    index =&gt; 3</span><br><span class="line">    index =&gt; 5</span><br><span class="line">    index =&gt; 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>Evils操作符</p>
<p>安全性操作符有三种：<code>?:</code> /<code>!!</code> / <code>as?</code></p>
<p><code>?:</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> testStr : String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例： 当testStr不为空时，输出其长度，反之输出-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">length = <span class="keyword">if</span> (testStr != <span class="literal">null</span>) testStr.length <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 写法</span></span><br><span class="line">length = testStr?.length ?: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">println(length)</span><br></pre></td></tr></table></figure>

<p><code>!!</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val testStr : String? = null</span><br><span class="line">println(testStr!!.length)</span><br><span class="line">//如果变量为空，使用!!修饰，运行时会抛出空指针异常</span><br></pre></td></tr></table></figure>

<p><code>as</code></p>
<p>使用<code>as</code>进行强制转换，在不能转换时会抛出异常，而使用<code>as?</code>则会返回<code>null</code>，但不会抛出异常。</p>
</li>
</ol>
<h2 id="Kotlin-函数"><a href="#Kotlin-函数" class="headerlink" title="Kotlin 函数"></a>Kotlin 函数</h2><ol>
<li><p>默认参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">defArgs</span><span class="params">(numA : <span class="type">Int</span>  = <span class="number">1</span>, numB : <span class="type">Float</span> = <span class="number">2</span>f, numC : <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">"numA  =  <span class="variable">$numA</span> \t numB = <span class="variable">$numB</span> \t numC = <span class="variable">$numC</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认参数的函数使用</span></span><br><span class="line">    defArgs()</span><br><span class="line">    defArgs(<span class="number">1</span>,<span class="number">10f</span>,<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>命名参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callFun(<span class="string">"str"</span>,isTrue = <span class="literal">true</span>,numA = <span class="number">3</span>) <span class="comment">//java中不支持这么写</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>可变参数</p>
<p>​    当一个函数中的参数是不定数量的个数并且是同一个类型，则可是使用<code>vararg</code>修饰符去修饰这个变量，则被<code>vararg</code>修饰的参数相当于一个固定类型的数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">varargFun</span><span class="params">(numA: <span class="type">Int</span>, <span class="keyword">vararg</span> str : <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (s <span class="keyword">in</span> str) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="comment">//    str[index]</span></span><br><span class="line"><span class="comment">//    str.component1() ... str.component5()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者其高阶函数用法</span></span><br><span class="line"><span class="comment">//    str.map &#123;  &#125;</span></span><br><span class="line"><span class="comment">//    str.filter &#123;  &#125;</span></span><br><span class="line"><span class="comment">//    str.sortBy &#123;  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">普通传递 : varargFun(1,"aaa","bbb","ccc","ddd","fff")</span></span><br><span class="line"><span class="comment">数组传递：</span></span><br><span class="line"><span class="comment">        val strArray = arrayOf("aaa","bbb","ccc","ddd","fff")</span></span><br><span class="line"><span class="comment">        varargFun(1,*strArray) // *叫做伸展操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>单表达式函数</p>
<p>​    函数具备返回值的时候，可以省略花括号并且在<code>=</code>赋值符号之后指定代码体，而函数的返回值是有编辑器自动推断的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> = <span class="number">2</span>                     <span class="comment">// 自动推断为：返回类型为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">(num : <span class="type">Int</span>)</span></span> = num * <span class="number">2</span>      <span class="comment">// 自动推断为：返回类型为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">(x : <span class="type">Float</span>, y : <span class="type">Int</span> = <span class="number">2</span>)</span></span> = x * y  <span class="comment">// 和默认参数一起使用，返回值为Float型</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ol>
<li><p>当类没有结构体时可以省略大括号：<code>class Test</code></p>
</li>
<li><p>主构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">constructor</span></span>(num :<span class="built_in">Int</span>)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>(num:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>初始化代码块</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> num:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">     	num = <span class="number">5</span></span><br><span class="line">        println(<span class="string">"num = <span class="variable">$num</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>如上，声明属性可以直接在类头声明</p>
</li>
<li><p>当构造函数不具有注释符或者使用默认的可见性修饰符时，可以省略constructor关键字</p>
</li>
<li><p>辅助构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    constructor(参数)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>同时存在主构造函数和二级构造函数</p>
<p>​    如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用<code>this</code>关键字对同一类的另一个构造函数进行委派：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class_example2</span> <span class="keyword">constructor</span></span>( num1:<span class="built_in">Int</span> = <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> num2 :<span class="built_in">Int</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(num1)</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>( num1:<span class="built_in">Int</span> = <span class="number">2</span>, num3:<span class="built_in">Int</span>):<span class="keyword">this</span>(num1)&#123;</span><br><span class="line">        println(<span class="string">"num3+num1 = <span class="variable">$num1</span> + <span class="variable">$num3</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//虽然这里写的是num3，但其实调用的是主构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(num1: <span class="built_in">Int</span> = <span class="number">2</span>,num3: <span class="built_in">Int</span>,num2:<span class="built_in">Int</span>):<span class="keyword">this</span>(num3)&#123; </span><br><span class="line">        println(<span class="string">"constructor - 3 para"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c :Class_example2 = Class_example2( <span class="number">3</span>,num3 = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> cc:Class_example2 = Class_example2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">num3+num1 = 3 + 3</span></span><br><span class="line"><span class="comment">2      </span></span><br><span class="line"><span class="comment">constructor - 3 para</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>当类的主构造函数都存在默认值的情况下</p>
<ul>
<li>在<code>JVM</code>上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用<code>Kotlin</code>与诸如<code>Jackson</code>或<code>JPA</code>的库，通过无参数构造函数创建类实例。</li>
<li>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</li>
<li>如果第一个第一个参数不是默认的，则不会有无参的，可以调用一个参数的。</li>
<li>总结：如果中间有不具备默认参数的，则到该参数为止都需要进行强制给值，直到参数赋值完或者后面的都是由默认值的形参。</li>
</ul>
</li>
<li><p>类的实例化</p>
<p>没有 <code>new</code> 关键字。</p>
</li>
<li><p>类的类别</p>
<p>密封类、内部类、抽象类、枚举类、接口类、数据类</p>
</li>
</ol>
<h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><ol>
<li><p>Getter &amp; Setter</p>
<pre><code>1. 在Kotlin中，想要外部变量不能访问某类内的变量则将Setter进行private修饰，若使用private修饰属性则该变量不能对该属性进行访问
 2. val属性不能有setter函数
 3. getter一般写，默认实现。写了 get()=&quot;修改也不变&quot;,则当前属性值永远为“修改也不变”</code></pre></li>
<li><p>修改访问器（Getter/Setter）的可见性</p>
<ol>
<li>get函数前面的可见性修饰符需要和属性一直</li>
<li>可以用@Inject set 来对实现<code>Setter</code></li>
<li>共有属性var，setter用private进行修饰，则表示该属性不能外部修改值。</li>
</ol>
</li>
<li><p>后备字段 <a href="https://stackoverflow.com/questions/43220140/whats-kotlin-backing-field-for" target="_blank" rel="noopener">(What is backing field)</a></p>
<ol>
<li><p>定义：如果属性使用至少一个访问器的<strong>默认实现</strong>，或者<strong>自定义访问通过field标识符引用</strong>，则将为属性生成后备字段。 （换句话，如果没有默认访问器实现 &amp;&amp; 没有自定义通过访问field标识符进行引用，则不会有后备字段）</p>
</li>
<li><p>原理：Kotlin中没有字段，但有后备字段。在isEmpty例子中可以学习到，判断类中是否为空不需要单独的字段，只需要对size进行判断即可，因此该变量不需要字段。而size则需要后备字段。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> isEmpty <span class="comment">//no backing field</span></span><br><span class="line">        <span class="keyword">get</span>() = size == <span class="number">0</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            size = size * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.size = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setEmpty</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.size *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>后备属性</p>
<p>_table是private 没有法访问，定义了table属性来对 _table进行get操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;  <span class="comment">/// table就是后备属性。</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</span><br><span class="line">            _table = HashMap() <span class="comment">// 初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ?: 操作符，如果_table不为空则返回，反之则抛出AssertionError异常</span></span><br><span class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>编译时常数</p>
<p>编译时常数必须为顶层声明，初始化为<code>String</code>或者基本类型，没有自定义的getter()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CONST_NUM = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CONST_STR = <span class="string">"Kotlin"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后期初始化属性</p>
<p>只能用于修饰var，没有自定义的setter与getter函数，属性必须为空且类型不能为基本类型。</p>
</li>
<li><p>委托属性</p>
</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>public、internal、protected、private</p>
<ol>
<li><p>顶层声明</p>
<ol>
<li>在顶层声明中，文件不能用protected修饰</li>
<li>不同文件中，访问顶层声明的可以访问，public和internal</li>
</ol>
</li>
<li><p>在类中声明</p>
<ol>
<li>类中可以使用任意修饰符，且类内可以任意访问</li>
<li>类外的函数，只能访问public和internal</li>
</ol>
</li>
<li><p>在接口中声明</p>
<ol>
<li>只能声明public属性。</li>
<li>修饰private类和private的方法</li>
<li>用private修饰的方法不能被实现该接口的类重载。</li>
</ol>
</li>
<li><p>在构造函数中的声明</p>
<ol>
<li>任意使用修饰符</li>
<li>在二级构造函数中，不能用任意修饰符，可以说是默认修饰（public）</li>
</ol>
</li>
<li><p>在局部声明中同上步中的二级构造函数</p>
</li>
<li><p>与Java中的对比</p>
<p>四个修饰符不同、默认修饰符不同</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>超类（Any）；用：符号继承</p>
</li>
<li><p>open修饰符</p>
<ol>
<li>open修饰符是定义继承类的修饰符</li>
<li>类和成员都需要使用open关键字</li>
</ol>
</li>
<li><p>继承类的构造函数</p>
<ol>
<li><p>实现类无主构造函数</p>
<p>每个辅助构造函数必须使用<code>super</code>关键字初始化或者委托给另一个构造函数。</p>
</li>
<li><p>存在主构造函数</p>
<p>主构造函数一般实现基类中参数最多的构造函数，参数少的哦那个this引用即可。</p>
</li>
</ol>
</li>
<li><p>函数的重写</p>
<ol>
<li><p>子类不能重写基类中没有用open修饰的同名函数。</p>
</li>
<li><p>当一个类不是用open修饰时，该类默认实final，不能被再次继承</p>
</li>
<li><p>子类用final关键字修饰方法，以此来禁止后续子类重写该方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B这个类继承类A，并且类B同样使用open修饰符修饰了的</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 这里使用final修饰符修饰该方法，禁止覆盖掉类A的foo()函数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="5">
<li><p>重写属性</p>
<ol>
<li><p>重写属性必须用override修饰。</p>
</li>
<li><p>当基类属性修饰为val时，实现类可以用var去重写，反之却不行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> valStr = <span class="string">"我是用val修饰的属性"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里用val、或者var重写都是可以的。</span></span><br><span class="line"><span class="comment">     * 不过当用val修饰的时候不能有setter()函数，编辑器直接会报红的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// override val valStr: String</span></span><br><span class="line">    <span class="comment">//   get() = super.valStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// override var valStr: String = ""</span></span><br><span class="line">    <span class="comment">//   get() = super.valStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// override val valStr: String = ""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> valStr: String = <span class="string">"abc"</span></span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arge: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">    println(DemoTest().valStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo = DemoTest()</span><br><span class="line">    demo.valStr = <span class="string">"1212121212"</span></span><br><span class="line">    println(demo.valStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写属性是不能用 get() = super.xxx，因为这样的话，不管你是否重新为该属性赋了新值，还是支持<code>setter()</code>,在使用的时候都调用的是基类中的属性值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里介绍重写属性是，getter()函数中使用`super`关键字的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> valStr: String = <span class="string">"abc"</span>、</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">super</span>.valStr</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arge: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">    println(DemoTest().valStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo = DemoTest()</span><br><span class="line">    demo.valStr = <span class="string">"1212121212"</span></span><br><span class="line">    println(demo.valStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也不能 get() = this.valStr / get() = valStr 。会报运行错误。</p>
<p>Exception：StackOverflowError</p>
<p>java.lang.StackOverflowError:stacksize8MBStackOverflowError是由于当前线程的栈满了,也就是函数调用层级过多导致。堆栈溢出错误一般是递归调用。出现这种异常,大多是由于循环调用。出现的情况:大多数都是在本方法中调用本方法。也就是我们常说的递归调用,所以才导致这个错误的出现。</p>
<p>应该用默认的 get() = field</p>
</li>
</ol>
</li>
<li><p>在主构造函数重写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest2</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> num: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> valStr: String) : Demo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> demo2 = DemoTest2(<span class="number">1</span>,<span class="string">"构造函数中重写"</span>)</span><br><span class="line">    println(<span class="string">"num = <span class="subst">$&#123;demo2.num&#125;</span> \t valStr = <span class="subst">$&#123;demo2.valStr&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>覆盖规则:解决两个接口方法名相同问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">open class A&#123;</span><br><span class="line">    open fun test1()&#123; println(&quot;基类A中的函数test1()&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    open fun test2()&#123;println(&quot;基类A中的函数test2()&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B&#123;</span><br><span class="line">    fun test1()&#123; println(&quot;接口类B中的函数test1()&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    fun test2()&#123;println(&quot;接口类B中的函数test2()&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C : A(),B&#123;</span><br><span class="line">    override fun test1() &#123;</span><br><span class="line">        super&lt;A&gt;.test1()</span><br><span class="line">        super&lt;B&gt;.test1()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun test2() &#123;</span><br><span class="line">        super&lt;A&gt;.test2()</span><br><span class="line">        super&lt;B&gt;.test2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="接口类-枚举类"><a href="#接口类-枚举类" class="headerlink" title="接口类/枚举类"></a>接口类/枚举类</h2><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ol>
<li><p>枚举类的初始化及使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum class Color(var argb : String)&#123;</span><br><span class="line">    RED(&quot;&quot;),</span><br><span class="line">    WHITE(&quot;&quot;),</span><br><span class="line">    BLACK(&quot;&quot;),</span><br><span class="line">    GREEN(&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量，枚举类中的每个枚举常量都是对象，用逗号分隔。（如上述的RED(“”),）</p>
<p>直接用<code>Color.RED</code>进行访问。</p>
</li>
<li><p>枚举常量匿名类，必须提供一个抽象方法，且该方法定义在枚举类内部。而且必须在枚举变量的后面，有抽象函数，则最后一个枚举变量必须用<code>;</code>隔开。</p>
</li>
<li><p>枚举常量的属性：name（常量名）和ordinal（常量位置）</p>
</li>
<li><p>可以用<code>enumValues&lt;T&gt;()</code> 和<code>enumValuesOf&lt;T&gt;()</code>访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(enumValues&lt;Color&gt;().joinToString &#123; it.name &#125;)</span><br><span class="line">println(enumValueOf&lt;Color&gt;(&quot;RED&quot;))</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">//RED, WHITE, BLACK, GREEN</span><br><span class="line">//RED</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>用 <code>valueof()</code>和<code>values()</code>检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(Color.valueOf(&quot;RED&quot;))</span><br><span class="line">println(Color.values()[0])</span><br><span class="line">println(Color.values()[1])</span><br><span class="line">println(Color.values()[2])</span><br><span class="line">println(Color.values()[3])</span><br></pre></td></tr></table></figure>

<p>其中，若使用<code>Color.valueOf(&quot;不存在的枚举常量&quot;)</code>，则会抛出<code>IllegalArgumentException</code> 异常，即枚举变量不存在。若使用<code>Color.values()[大于枚举常量位置]</code>，则会抛出下标越界异常。</p>
</li>
</ol>
<h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><ol>
<li>用<code>：</code>进行对接口的实现</li>
<li>Kotlin中接口中可以写属性，作为抽象属性、作为访问器</li>
<li>多接口可用<code>super&lt;接口名&gt;.方法名</code>来区分。</li>
</ol>
<h2 id="数据类和密封类"><a href="#数据类和密封类" class="headerlink" title="数据类和密封类"></a>数据类和密封类</h2><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><ol>
<li>关键字<code>data</code></li>
<li>构造函数必须存在至少一个参数。</li>
<li>数据类的特性：<ol>
<li>数据类不能是抽象的、开放的、密封的或者内部的。</li>
<li>数据类可以实现接口，同时也可以继承其他类，如密封类。</li>
</ol>
</li>
</ol>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><ol>
<li>关键字<code>sealed</code></li>
<li>sealed class SealedExpr()</li>
<li>密封类<strong>不能被实例化</strong>，他的作用是<em>表示受限的类继承结构</em></li>
<li>密封类可以有多个实例。</li>
<li>密封类的子类必须是在密封类的内部或必须存在于密封类的同一文件，密封类可以有效地保护代码。</li>
</ol>
<h2 id="抽象类-amp-内部类"><a href="#抽象类-amp-内部类" class="headerlink" title="抽象类&amp;内部类"></a>抽象类&amp;内部类</h2><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol>
<li>抽象类有抽象成员，抽象成员都带<code>abstract</code>关键字</li>
<li>Kotlin中的抽象类，在顶层定义时只能使用<code>public</code></li>
<li>抽象类中可以定义内部抽象类</li>
<li>只能继承一个抽象类</li>
<li>抽象类，可以通过子类向上转型</li>
<li>抽象类可以继承另一个类，但不建议用open修饰抽象类</li>
</ol>
<h4 id="嵌套类类"><a href="#嵌套类类" class="headerlink" title="嵌套类类"></a>嵌套类类</h4><ol>
<li><p>定义：一个类嵌套在另一个类当中</p>
</li>
<li><p><code>外部类.嵌套类().嵌套类方法/属性。在调用的时候嵌套类是需要实例化的</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"test"</span>, <span class="string">"Nested -&gt; execute"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Outter.Nested().execute()</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Nested -&gt; execute</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ol>
<li><p>定义：用inner class 来进行声明类</p>
</li>
<li><p>内部类不能直接被实例化，需要外部的类实例化了对象，再利用该对象进行实例化内部类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> testVal = <span class="string">"test"</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"test"</span>, <span class="string">"Inner -&gt; execute : can read testVal=<span class="variable">$testVal</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">val</span> outter = Outter()</span><br><span class="line">outter.Inner().execute()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Inner -&gt; execute : can read testVal=test</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>监听器的实现方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.zju.maple.learning</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NickInnerClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">private</span> <span class="keyword">var</span> listener:OnClickListener</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClickListener</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">activeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        listener.onItemClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nick = NickInnerClass()</span><br><span class="line">    nick.setOnClickListener(<span class="keyword">object</span>:OnClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            println(<span class="string">"执行了activeListener函数，才有这句输出"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">20</span>)&#123;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        nick.activeListener() <span class="comment">///唤醒方法</span></span><br><span class="line">        <span class="keyword">for</span> ( temp <span class="keyword">in</span> <span class="number">1</span>..<span class="number">0xFFFF</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h4 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h4><ol>
<li>局部类只能在定义该局部类的方法中使用</li>
<li>定义在实例方法中的局部类可以访问外部类的所有变量和方法，但不能修改</li>
<li>局部类可以定义属性、方法。</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol>
<li><p>将函数作为参数或者返回值的函数称为高阶函数。</p>
<ol>
<li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///函数作为参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resultByOpt</span><span class="params">(num1 : <span class="type">Int</span> , num2 : <span class="type">Int</span> , result : (<span class="type">Int</span> ,<span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result(num1,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = resultByOpt(<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result2 = resultByOpt(<span class="number">3</span>,<span class="number">4</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 - num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result3 = resultByOpt(<span class="number">5</span>,<span class="number">6</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 * num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result4 = resultByOpt(<span class="number">6</span>,<span class="number">3</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 / num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"result1 = <span class="variable">$result1</span>"</span>)</span><br><span class="line">    println(<span class="string">"result2 = <span class="variable">$result2</span>"</span>)</span><br><span class="line">    println(<span class="string">"result3 = <span class="variable">$result3</span>"</span>)</span><br><span class="line">    println(<span class="string">"result4 = <span class="variable">$result4</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///返回值为函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test5</span><span class="params">(a:<span class="type">Int</span>)</span></span>:()-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">    println(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        println(<span class="string">"b=&gt; <span class="variable">$b</span>"</span>)</span><br><span class="line">        b++</span><br><span class="line">        <span class="keyword">return</span> b + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>常用的标准高阶函数</p>
<ol>
<li><p>TODO函数：将会抛出异常，根据参数的内容输出异常内容</p>
</li>
<li><p>run函数：两种用法</p>
<p>​    当我们需要执行一个<code>代码块</code>的时候就可以用到这个函数,并且这个代码块是独立的。即我可以在<code>run()</code>函数中写一些和项目无关的代码，因为它不会影响项目的正常运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testRun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"kotlin"</span></span><br><span class="line"></span><br><span class="line">    run&#123;</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">"java"</span>   <span class="comment">// 和上面的变量不会冲突</span></span><br><span class="line">        println(<span class="string">"str = <span class="variable">$str</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"str = <span class="variable">$str</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<pre><code>​    因为`run`函数执行了我传进去的`lambda`表达式并返回了执行的结果，所以当一个业务逻辑都需要执行同一段代码而根据不同的条件去判断得到不同结果的时候。可以用到`run`函数

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> index = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> num = run &#123;</span><br><span class="line">    <span class="keyword">when</span>(index)&#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="string">"kotlin"</span></span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">"java"</span></span><br><span class="line">        <span class="number">2</span> -&gt; <span class="string">"php"</span></span><br><span class="line">        <span class="number">3</span> -&gt; <span class="string">"javaScript"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">"none"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.length</span><br><span class="line">println(<span class="string">"num = <span class="variable">$num</span>"</span>)</span><br></pre></td></tr></table></figure>



​    被一个对象所调用。**当我们传入的lambda表达式想要使用当前对象的上下文的时候，我们可以使用这个函数。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val str = &quot;kotlin&quot;</span><br><span class="line">str.run &#123;</span><br><span class="line">    println( &quot;length = $&#123;this.length&#125;&quot; )</span><br><span class="line">    println( &quot;first = $&#123;first()&#125;&quot;)</span><br><span class="line">    println( &quot;last = $&#123;last()&#125;&quot; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="3">
<li>同时还有<code>with</code> / <code>let</code> / <code>apply</code> / <code>also</code> / <code>takeIf()</code> / <code>takeUnless</code> / <code>repeat()</code> / <code>lazy()</code> 分别有不同的用法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/07/15/2019-07-15- Kotlin 学习记录/" data-id="cjzm2ty02001g0gtadj9thtpi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-31- C# 查看串口" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/2019-05-31- C# 查看串口/" class="article-date">
  <time datetime="2019-05-30T16:00:00.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/2019-05-31- C# 查看串口/">C# 查看串口</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b> C# 查看串口 </b></h2></center><br>

<h3 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h3><p>​        在</p>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ol>
<li><p>在WPF中，每一个窗口都拥有一个Loaded事件传入接口，可以将函数传入该接口（即把函数委托给Loaded事件）。Loaded事件在元素即将要被渲染时触发。</p>
</li>
<li><p>在Loaded时定义拦截Windows消息拦截事件。事件函数（DeviceChanged）被委托给HwndSource的Hook。</p>
</li>
<li><p>在DeviceChanged函数中过滤串口插拔事件，并执行串口插拔后需要完善的逻辑操作。</p>
<ol start="4">
<li>事件序号：0x219 移动设备改变事件。0x8000设备插入事件。0x8004设备拔出事件。</li>
</ol>
</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; public MainWindow()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     Loaded+=MainWindow_Loaded;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; void MainWindow_Loaded(object sender,RoutedEventArgs e)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     HwndSource hwndSource = PresentationSource.FromVisual(this) as HwndSource;</span><br><span class="line">&gt;     if(null!=hwndSource)</span><br><span class="line">&gt;     	hwndSource.AddHook(new HwndSourceHook(DevieceChanged));</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; private IntPtr DeviceChanged(IntPtr hwnd,int msg,IntPtr wParam,IntPtr lParam,ref bool handled)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     string[] PortNames;</span><br><span class="line">&gt;     if (msg == WM_DEVICECHANGE)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         switch (wParam.ToInt32())</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             case DBT_DEVICEARRIVAL://设备插入  </span><br><span class="line">&gt;                 PortNames = SerialPort.GetPortNames();</span><br><span class="line">&gt;                 if (IsWorking == true &amp;&amp; PortNames.Contains(ConfigInfo.Port))</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     if (serialPortUtil != null)</span><br><span class="line">&gt;                     &#123;</span><br><span class="line">&gt;                         serialPortUtil.OpenPort();</span><br><span class="line">&gt;                         MsgBox.Show(&quot;串口连接成功！&quot;);</span><br><span class="line">&gt;                     &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;             case DBT_DEVICEREMOVECOMPLETE: //设备卸载</span><br><span class="line">&gt;                 PortNames = SerialPort.GetPortNames();  </span><br><span class="line">&gt;                 if (IsWorking == true &amp;&amp; !PortNames.Contains(ConfigInfo.Port))</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     MsgBox.Show(&quot;串口连接断开！&quot;);</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;             default:</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return IntPtr.Zero; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<pre><code>
通过该方法可以实现对串口插拔事件的监听。







参考内容

​        [C#获取串口列表](https://www.cnblogs.com/xj2015/p/6100406.html)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/31/2019-05-31- C# 查看串口/" data-id="cjzm2txyk000d0gtasut1plkz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/串口通讯/">串口通讯</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-30- C# 监听串口插拔事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/2019-05-30- C# 监听串口插拔事件/" class="article-date">
  <time datetime="2019-05-29T16:00:00.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/2019-05-30- C# 监听串口插拔事件/">C# 监听串口插拔事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b> C# 监听串口插拔事件 </b></h2></center><br>

<h3 id="场景简述"><a href="#场景简述" class="headerlink" title="场景简述"></a>场景简述</h3><p>​        在进行C#串口开发时，往往需要对可访问的串口通过ComboList组件进行呈现共用户进行选择软件需要连接的串口，在这过程中就需要对串口的插拔事件进行监听。当事件到来对列表、串口开关进行对应的变化。使得整个软件操作起来更加合理。</p>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ol>
<li><p>在WPF中，每一个窗口都拥有一个Loaded事件传入接口，可以将函数传入该接口（即把函数委托给Loaded事件）。Loaded事件在元素即将要被渲染时触发。</p>
</li>
<li><p>在Loaded时定义拦截Windows消息拦截事件。事件函数（DeviceChanged）被委托给HwndSource的Hook。</p>
</li>
<li><p>在DeviceChanged函数中过滤串口插拔事件，并执行串口插拔后需要完善的逻辑操作。</p>
<ol start="4">
<li>事件序号：0x219 移动设备改变事件。0x8000设备插入事件。0x8004设备拔出事件。</li>
</ol>
</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; public MainWindow()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     Loaded+=MainWindow_Loaded;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; void MainWindow_Loaded(object sender,RoutedEventArgs e)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     HwndSource hwndSource = PresentationSource.FromVisual(this) as HwndSource;</span><br><span class="line">&gt;     if(null!=hwndSource)</span><br><span class="line">&gt;     	hwndSource.AddHook(new HwndSourceHook(DevieceChanged));</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; private IntPtr DeviceChanged(IntPtr hwnd,int msg,IntPtr wParam,IntPtr lParam,ref bool handled)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     string[] PortNames;</span><br><span class="line">&gt;     if (msg == WM_DEVICECHANGE)</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         switch (wParam.ToInt32())</span><br><span class="line">&gt;         &#123;</span><br><span class="line">&gt;             case DBT_DEVICEARRIVAL://设备插入  </span><br><span class="line">&gt;                 PortNames = SerialPort.GetPortNames();</span><br><span class="line">&gt;                 if (IsWorking == true &amp;&amp; PortNames.Contains(ConfigInfo.Port))</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     if (serialPortUtil != null)</span><br><span class="line">&gt;                     &#123;</span><br><span class="line">&gt;                         serialPortUtil.OpenPort();</span><br><span class="line">&gt;                         MsgBox.Show(&quot;串口连接成功！&quot;);</span><br><span class="line">&gt;                     &#125;</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;             case DBT_DEVICEREMOVECOMPLETE: //设备卸载</span><br><span class="line">&gt;                 PortNames = SerialPort.GetPortNames();  </span><br><span class="line">&gt;                 if (IsWorking == true &amp;&amp; !PortNames.Contains(ConfigInfo.Port))</span><br><span class="line">&gt;                 &#123;</span><br><span class="line">&gt;                     MsgBox.Show(&quot;串口连接断开！&quot;);</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;             default:</span><br><span class="line">&gt;                 break;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     return IntPtr.Zero; </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
</blockquote>
<pre><code>
通过该方法可以实现对串口插拔事件的监听。







参考文献

​        [C# WPF USB 串口插入拔出识别监测](https://blog.csdn.net/barry_hui/article/details/80326403)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/30/2019-05-30- C# 监听串口插拔事件/" data-id="cjzm2txyi000a0gta8fli8ffv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/串口通讯/">串口通讯</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-19- 设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/19/2019-05-19- 设计模式/" class="article-date">
  <time datetime="2019-05-18T16:00:00.000Z" itemprop="datePublished">2019-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/19/2019-05-19- 设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b> 设计模式 </b></h2></center><br>

<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>​    不能滥用static。</p>
<p>​    正常的设计模式上不能随便使用static变量，应该先懂得如何编写足以证明“赋值结果冲突、混乱”的测试用例，然后再使用static变量<sup><a href="https://bbs.csdn.net/topics/392167990?page=1" target="_blank" rel="noopener">[1]</a></sup>。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p><b>生产者消费者模式</b></p>
<p><b>观察者模式</b>&gt;</p>
<p><b>单例模式</b></p>
<p><b>工厂模式</b></p>
<h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/19/2019-05-19- 设计模式/" data-id="cjzm2txyn000f0gtamp27drol" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-18- C# 访问UI线程的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/18/2019-05-18- C# 访问UI线程的方法/" class="article-date">
  <time datetime="2019-05-17T16:00:00.000Z" itemprop="datePublished">2019-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/2019-05-18- C# 访问UI线程的方法/">C# 访问UI线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>C# 访问UI线程</b></h2></center><br>

<ul>
<li><h4 id="采用SynchronizationContext的Post-Send方法更新"><a href="#采用SynchronizationContext的Post-Send方法更新" class="headerlink" title="采用SynchronizationContext的Post/Send方法更新"></a>采用SynchronizationContext的Post/Send方法更新</h4><p>​        异步更新UI控件需要两步：</p>
<p>&emsp;&emsp; 1. 是要获取UI线程的上下文</p>
<p>&emsp;&emsp; 2. 调用post方法</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; public class ChangeUI //处在另一个线程</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;      SynchronizationContext _syncContext = null; </span><br><span class="line">&gt; </span><br><span class="line">&gt;      publc ChangeUI()&#123;</span><br><span class="line">&gt;          _syncContext = SynchronizationContext.Current; </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      public update()&#123;</span><br><span class="line">&gt;             Thread demoThread =new Thread(new ThreadStart(threadMethod)); </span><br><span class="line">&gt;             demoThread.Start();//启动线程         </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      private void threadMethod() &#123;</span><br><span class="line">&gt;          syncContext.Post(changeControl, &quot;修改后的文本&quot;);//子线程中通过UI线程上下文更新UI </span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      prviate void changeControl()&#123;</span><br><span class="line">&gt;          //执行设置控件代码</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><h4 id="使用控件自身的invoke-BeginInvoke方法"><a href="#使用控件自身的invoke-BeginInvoke方法" class="headerlink" title="使用控件自身的invoke/BeginInvoke方法"></a><strong>使用控件自身的invoke/BeginInvoke方法</strong></h4><p>&emsp;&emsp;继承Control类的UI控件都可以使用Invoke方法异步更新</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; private void button6_Click(object sender, EventArgs e) </span><br><span class="line">&gt; &#123; </span><br><span class="line">&gt;    Thread demoThread =new Thread(new ThreadStart(threadMethod)); </span><br><span class="line">&gt;    demoThread.IsBackground = true; </span><br><span class="line">&gt;    demoThread.Start();//启动线程 </span><br><span class="line">&gt; &#125; </span><br><span class="line">&gt;   </span><br><span class="line">&gt;  void threadMethod() </span><br><span class="line">&gt;  &#123;  </span><br><span class="line">&gt;    Action&lt;String&gt; AsyncUIDelegate=delegate(string n)&#123;label1.Text=n;&#125;;</span><br><span class="line">&gt;    label1.Invoke(AsyncUIDelegate,new object[]&#123;&quot;修改后的label1文本&quot;&#125;); </span><br><span class="line">&gt;  &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/18/2019-05-18- C# 访问UI线程的方法/" data-id="cjzm2txyj000b0gtawn5p6xvq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-18- C# 委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/18/2019-05-18- C# 委托/" class="article-date">
  <time datetime="2019-05-17T16:00:00.000Z" itemprop="datePublished">2019-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/2019-05-18- C# 委托/">C# 委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>C# 委托</b></h2></center><br>

<ul>
<li><strong>委托的概念</strong>：<br></li>
</ul>
<p>&emsp;委托是一个类，它定义了方法的类型，使一个方法可以当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。。 </p>
<ul>
<li><p><strong>常见委托的使用</strong>：<br></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; delegate int MethodDelegate(int x,inty);</span><br><span class="line">&gt; </span><br><span class="line">&gt; MethodDelegate method = new MethodDelegate(function_name);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  MethodDelegate method = function_name;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&emsp;<strong>将对应的函数名放入function_name位置，函数的签名需要和委托声明的一样。</strong></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; //使用匿名方法</span><br><span class="line">&gt; MyDelegate myDelegate = delegate(int x, int y)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     return x + y;</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; //使用Lambda表达式</span><br><span class="line">&gt; MyDelegate myDelegateLambda = (int x, int y) =&gt; &#123; return x + y; &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>其他委托的分类</strong>：</p>
<p><strong>1.Action</strong></p>
<p>Action作为一种反省委托，不具备返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Test&lt;string&gt;(Action,&quot;Hello World!&quot;);</span><br><span class="line">            Test&lt;int&gt;(Action, 1000);</span><br><span class="line">            Test&lt;string&gt;(p =&gt; &#123; Console.WriteLine(&quot;&#123;0&#125;&quot;, p); &#125;, &quot;Hello World&quot;);</span><br><span class="line">    		//使用Lambda表达式定义委托</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">        public static void Test&lt;T&gt;(Action&lt;T&gt; action, T p)</span><br><span class="line">        &#123;</span><br><span class="line">            Action(p);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void Action(string s)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line">        &#125;</span><br><span class="line">        private static void Action(int s)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(s);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.Func</strong></p>
<p>Func是返回值的泛型委托</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(Test&lt;int,int&gt;(Fun,100,200));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">        public static int Test&lt;T1, T2&gt;(Func&lt;T1, T2, int&gt; func, T1 a, T2 b)</span><br><span class="line">        &#123;</span><br><span class="line">            return func(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        private static int Fun(int a, int b)</span><br><span class="line">        &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.predicate</strong>：</p>
<p>predicate是返回值bool的泛型委托</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public delegate int MethodDelegate(int x, int y);</span><br><span class="line">        private static MethodDelegate method;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            method = new MethodDelegate(Add);</span><br><span class="line">            Console.WriteLine(method(10,20));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private static int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>委托的好处</strong>：</p>
<ol>
<li><p>相当于用方法作为另一方法参数(类似于C的函数指针)</p>
</li>
<li><p>在两个不能直接调用的方法中作为桥梁,如:在多线程中的跨线程的方法调用就得用委托</p>
</li>
<li><p>当不知道方法具体实现什么时使用委托,如:事件中使用委托</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>注意事项与特点</strong>：<br></p>
<p>&emsp;1. 虽然委托的定义有点像方法的声明，但是委托是属于类的层面。</p>
<p>&emsp;2. 委托类似于C++的函数指针，但是它是类型安全的</p>
<p>&emsp;3.委托允许将方法作为参数进行传递。</p>
<p>&emsp;4. Delegate至少0个参数，至多32个参数，可以无返回值，也可以指定返回值类型</p>
<p>　5. Func可以接受0个至16个传入参数，必须具有返回值</p>
<p>　6. Action可以接受0个至16个传入参数，无返回值</p>
<p>　7 Predicate只能接受一个传入参数，返回值为bool类型</p>
</li>
</ul>
<p>相关博客：</p>
<p>​        <a href="https://www.cnblogs.com/yinqixin/p/5056307.html" target="_blank" rel="noopener">分分钟用上C#中的委托和事件</a> （该文学习将委托是事件结合，从而实现一个对象发送指令，其他的对象根据不同指令进行自己的操作的功能）</p>
<p>​        </p>
<p>Thanks to <a href="https://www.cnblogs.com/zhangchenliang/" target="_blank" rel="noopener">Danny Chen</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/18/2019-05-18- C# 委托/" data-id="cjzm2txyf00070gta5oynjfqk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-05-09-Intel .hex file" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/09/2019-05-09-Intel .hex file/" class="article-date">
  <time datetime="2019-05-08T16:00:00.000Z" itemprop="datePublished">2019-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/09/2019-05-09-Intel .hex file/">.HEX file</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>.HEX file</b></h2></center><br>


<h3 id="HEX-文件介绍"><a href="#HEX-文件介绍" class="headerlink" title="HEX 文件介绍"></a>HEX 文件介绍</h3><p>&emsp;Keil HEX文件是由一行行符合Intel HEX文件格式的文本所构成的ASCII文本文件。在Intel HEX文件中，每一行包含一个HEX记录。这些记录由对应机器语言码和/或常量数据的十六进制编码数字组成。Intel HEX文件通常用于传输将被存于ROM或者EPROM中的程序和数据。大多数EPROM编程器或模拟器使用Intel HEX文件。 </p>
<h3 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h3><ul>
<li><p><strong>记录格式</strong>：<br>&emsp;Intel HEX由任意数量的十六进制记录组成。每个记录包含5个域，它们按以下格式排列： </p>
<blockquote>
<p>:llaaaatt[dd…]cc </p>
</blockquote>
<p>&emsp;每一组字母对应一个不同的域，每一个字母对应一个<strong>十六进制</strong>编码的数字。每一个域由至少两个十六进制编码数字组成，它们构成一个字节，如下描述： </p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">符号意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:</td>
<td align="left">每个Intel HEX记录都由冒号开头.</td>
</tr>
<tr>
<td align="left">ll</td>
<td align="left">是<strong>数据长度域</strong>,它代表记录当中数据字节(dd)的数量.</td>
</tr>
<tr>
<td align="left">aaaa</td>
<td align="left">是<strong>地址域</strong>,它代表记录当中数据的起始地址.</td>
</tr>
<tr>
<td align="left"><strong>tt</strong></td>
<td align="left">是代表HEX记录类型的域,它可能是以下数据当中的一个:<br>&gt; 00 – 数据记录<br>&gt; 01 – 文件结束记录<br>&gt; 02 – 扩展段地址记录 <br>&gt; 04 – 扩展线性地址记录<br>&gt; 05 - 运行地址记录</td>
</tr>
<tr>
<td align="left">dd</td>
<td align="left">是<strong>数据域</strong>,它代表一个字节的数据. 一个记录可以有许多数据字节.记录当中数据字节的数量必须和数据长度域(ll)中指定的数字相符.</td>
</tr>
<tr>
<td align="left">cc</td>
<td align="left">是校验和域,它表示这个记录的校验和.校验和的计算是通过将记录当中所有十六进制编码数字对的值相加,以256为模进行以下补足.</td>
</tr>
</tbody></table>
</li>
<li><p><strong>扩展线性地址记录</strong>(HEX386) ：<br><br>&emsp;扩展线性地址记录也叫作32位地址记录或HEX386记录.这些记录包含数据地址的高16位.扩展线性地址记录总是有两个数据字节,外观如下: </p>
<blockquote>
<p>:02000004FFFFFC </p>
</blockquote>
<p>其中: </p>
<table>
<thead>
<tr>
<th align="left">数据</th>
<th>数据意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">02</td>
<td>这个记录当中数据字节的数量</td>
</tr>
<tr>
<td align="left">0000</td>
<td>地址域,对于扩展线性地址记录,这个域总是0000.</td>
</tr>
<tr>
<td align="left">04</td>
<td>记录类型 04(扩展线性地址记录)</td>
</tr>
<tr>
<td align="left"><strong>FFFF</strong></td>
<td>地址的高16位.</td>
</tr>
<tr>
<td align="left">FC</td>
<td>是这个记录的校验和,计算方法如下: <br>&gt;&gt; 01h + NOT(02h + 00h + 00h + 04h + FFh + FFh).</td>
</tr>
</tbody></table>
</li>
</ul>
<p>  &emsp;当一个扩展线性地址记录被读取,存储于数据域的扩展线性地址被保存,它被应用于从Intel HEX文件读取来的随后的记录.线性地址保持有效,直到它被另外一个扩展地址记录所改变. </p>
<p>  &emsp;通过把记录当中的地址域与被移位的来自扩展线性地址记录的地址数据相加获得数据记录的绝对存储器地址. </p>
<p>  假设：</p>
<blockquote>
<p>来自数据记录地址域的地址 2462 </p>
<p>扩展线性地址记录的数据域 + FFFF </p>
<p>绝对存储器地址 FFFF2462 </p>
</blockquote>
<hr>
<ul>
<li><p><strong>扩展段地址记录</strong>(HEX386) ：<br><br>&emsp;扩展段地址记录也叫HEX86记录,它包括<strong>4-19</strong>位数据地址段.扩展段地址记录总是有两个数据字节,外观如下: </p>
<blockquote>
<p>:020000021200EA </p>
</blockquote>
<p>其中: </p>
<table>
<thead>
<tr>
<th align="left">数据</th>
<th>数据意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">02</td>
<td>这个记录当中数据字节的数量</td>
</tr>
<tr>
<td align="left">0000</td>
<td>地址域.对于扩展段地址记录,这个域总是0000.</td>
</tr>
<tr>
<td align="left">02</td>
<td>是记录类型 02(扩展段地址记录)</td>
</tr>
<tr>
<td align="left"><strong>1200</strong></td>
<td>1200 是地址段.</td>
</tr>
<tr>
<td align="left">EA</td>
<td>是这个记录的校验和,计算方法如下:  &gt;&gt; 01h + NOT(02h + 00h + 00h + 02h + 12h + 00h).</td>
</tr>
</tbody></table>
</li>
</ul>
<p>  &emsp;当一个扩展段地址记录被读取,存储于数据域的扩展段地址被保存,它被应用于从Intel HEX文件读取来的随后的记录.段地址保持有效,直到它被另外一个扩展地址记录所改变. </p>
<p>  &emsp;通过把记录当中的地址域与被移位的来自扩展段地址记录的地址数据相加获得数据记录的绝对存储器地址. </p>
<p>  以下的例子演示了这个过程.</p>
<blockquote>
<p>来自数据记录地址域的地址 2462 </p>
<p>扩展段地址记录数据域 + 1200 &lt;&lt;1</p>
<p>绝对存储器地址 00014462 </p>
</blockquote>
<hr>
<ul>
<li><p><strong>文件结束(EOF)记录</strong>(HEX386) ：<br><br>&emsp;Intel HEX文件必须以文件结束(EOF)记录结束.这个记录的记录类型域的值必须是01.EOF记录外观总是如下: </p>
<blockquote>
<p>:00000001FF </p>
</blockquote>
<p>其中: </p>
<table>
<thead>
<tr>
<th align="left">数据</th>
<th>数据意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00</td>
<td>这个记录当中数据字节的数量</td>
</tr>
<tr>
<td align="left">0000</td>
<td>是数据被下载到存储器当中的地址.在文件结束记录当中地址是没有意义被忽略的.0000h是典型的地址.</td>
</tr>
<tr>
<td align="left">01</td>
<td>记录类型 01(文件结束记录)</td>
</tr>
<tr>
<td align="left">FF</td>
<td>这个记录的校验和,计算方法如下: <br>&gt;&gt; 01h + NOT(00h + 00h + 00h + 01h).</td>
</tr>
</tbody></table>
</li>
</ul>
<ul>
<li><p><strong>文件整体分析</strong> ：<br><br></p>
<p>第一行 :02 0000 04 0800 F2</p>
<p>第二行 :10 0000 00 <strong>78060020</strong>51040008690200086B020008 0D</p>
<p>&emsp;&emsp;注意：地址是大开端，0800+0000 = 0x08000000</p>
<p><strong>&emsp;&emsp;78060020</strong>是MSP初始值，其实为0x20000678,是小开端。</p>
<p>&emsp;&emsp;51040008 = 08000451 reset isr地址</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">151:             LDR     R0, =SystemInit   ß-----------resetHandle</span><br><span class="line"></span><br><span class="line">0x08000450 4809  LDR      r0,[pc,#36]  ; @0x08000478</span><br><span class="line"></span><br><span class="line">152:             BLX     R0                </span><br><span class="line"></span><br><span class="line">0x08000452 4780  BLX      r0</span><br></pre></td></tr></table></figure>





<p>  倒数第二行 :04 0000 05 08000131 BD， 05表示开始运行地址，08000131是地址的值。</p>
<p>  倒数第一行 :00 0000 01 FF，hex文档结束</p>
<p>  &emsp;08000131为开始地址_main(),08000451为resetHandle地址，由于resethandle里面有systeminit函数，所以以resethandle为准！这两个都不用下载。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/05/09/2019-05-09-Intel .hex file/" data-id="cjzm2txyg00080gta58alyrh3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/downloader/">downloader</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mcu/">mcu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/parsing-file/">parsing file</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-24- Noted" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/26/2019-04-24- Noted/" class="article-date">
  <time datetime="2019-04-25T16:00:00.000Z" itemprop="datePublished">2019-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/26/2019-04-24- Noted/">Job Noted</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>Noted</b></h2></center><br>


<h3 id="华为："><a href="#华为：" class="headerlink" title="华为："></a>华为：</h3><p><strong>实习：</strong></p>
<p>华为实习生分类（可在杭州）：</p>
<p>​        （通用软件工程师）无线网络产品线、数据通信产品线、Cloud &amp; AI(Cloud BU)、Cloud &amp; AI(IT产品线)、海思半导体与器件业务部。</p>
<p>​        （操作系统工程师）中央软件院、中央研究院</p>
<p>​        （云计算开发工程师）无线网络产品线、数据通信产品线、Cloud &amp; AI(Cloud BU)、Cloud &amp; AI(IT产品线)、海思半导体与器件业务部、中央软件院。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/04/26/2019-04-24- Noted/" data-id="cjzm2txyb00030gtatmh2t9aw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/poems/">poems</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sentence/">sentence</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-24- C++ Sorting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/24/2019-04-24- C++ Sorting/" class="article-date">
  <time datetime="2019-04-23T16:00:00.000Z" itemprop="datePublished">2019-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/24/2019-04-24- C++ Sorting/">Sorting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>Sorting</b></h2></center><br>

<h3 id="C-排序算法："><a href="#C-排序算法：" class="headerlink" title="C++ 排序算法："></a>C++ 排序算法：</h3><h4 id="归并："><a href="#归并：" class="headerlink" title="归并："></a><strong>归并：</strong></h4><hr>
<p><strong>原理 ：</strong></p>
<p>​    归并排序：采用归并的思想，分治策略。<br>    将数据不断的进行二分，直到二分为仅一个数。回溯，两个数进行<em>归并</em> 之后，回溯，进行四个数据的<em>归并</em>。在归并时根据要求按顺序合并。依次回溯至迭代起点，归并排序就已完成。</p>
<p>​    归并的过程：就是将两组顺序的数据，根据数据的大小顺序存入连续内存空间，从而使得数据有序。</p>
<p><strong>代码：</strong></p>
<p>Please wait the lazy man!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/04/24/2019-04-24- C++ Sorting/" data-id="cjzm2txy800010gtagnbrwswq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-04-24- some words" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/24/2019-04-24- some words/" class="article-date">
  <time datetime="2019-04-23T16:00:00.000Z" itemprop="datePublished">2019-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/24/2019-04-24- some words/">语情集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b>语情集</b></h2></center><br>


<h3 id="信手一笔："><a href="#信手一笔：" class="headerlink" title="信手一笔："></a>信手一笔：</h3><p><strong>云志：</strong></p>
<blockquote>
<p>不知似梦似前程，信步青云脚下踩。 <br>长途漫漫不济路，只为千里赏昙花。</p>
</blockquote>
<blockquote>
<p> 望，细呷今朝淡觉甜<br>盼，酌品前途深作研</p>
</blockquote>
<p><strong>思乡：</strong></p>
<blockquote>
<p>洋洋溢溢归故去<br><br>摇身梦醒过辰时<br>身在外婆桥下走<br>良辰佳节惜寸金</p>
</blockquote>
<p><strong>道情：</strong></p>
<blockquote>
<p>一系扬州红绳，从此思念相瘦<br></p>
</blockquote>
<blockquote>
<p>十八束发成人日，一指白蜜不忍抹<br>两眸相视情初起，如今朝夕已四年</p>
</blockquote>
<blockquote>
<p>万卷书来不如汝之一频、一笑、一驻留。<br>一纸情深堪比鸳鸯百媚、千转、万间情。</p>
</blockquote>
<blockquote>
</blockquote>
<!--**自省**-->







<h3 id><a href="#" class="headerlink" title></a><!--摘：--></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/04/24/2019-04-24- some words/" data-id="cjzm2txye00050gtaqsps6ttk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/poems/">poems</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sentence/">sentence</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/downloader/">downloader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/halve/">halve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jekyll/">jekyll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mcu/">mcu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/parsing-file/">parsing file</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poems/">poems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentence/">sentence</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/串口通讯/">串口通讯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/C/" style="font-size: 20px;">C#</a> <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/downloader/" style="font-size: 10px;">downloader</a> <a href="/tags/halve/" style="font-size: 10px;">halve</a> <a href="/tags/jekyll/" style="font-size: 10px;">jekyll</a> <a href="/tags/mcu/" style="font-size: 10px;">mcu</a> <a href="/tags/parsing-file/" style="font-size: 10px;">parsing file</a> <a href="/tags/poems/" style="font-size: 13.33px;">poems</a> <a href="/tags/sentence/" style="font-size: 13.33px;">sentence</a> <a href="/tags/串口通讯/" style="font-size: 13.33px;">串口通讯</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/15/2019-07-15- Kotlin 学习记录/">Kotlin 学习记录</a>
          </li>
        
          <li>
            <a href="/2019/05/31/2019-05-31- C# 查看串口/">C# 查看串口</a>
          </li>
        
          <li>
            <a href="/2019/05/30/2019-05-30- C# 监听串口插拔事件/">C# 监听串口插拔事件</a>
          </li>
        
          <li>
            <a href="/2019/05/19/2019-05-19- 设计模式/">设计模式</a>
          </li>
        
          <li>
            <a href="/2019/05/18/2019-05-18- C# 访问UI线程的方法/">C# 访问UI线程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>