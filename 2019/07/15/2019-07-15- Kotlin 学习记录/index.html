<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Kotlin 学习记录 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Kotlin 学习记录   本文只记录重要的或者与C/C++、Java 出入较大的内容，或者我未习得的知识点Kotlin 变、常量用法 在类中定义变量必须初始化，暂时不能初始化的可用lateinit[后期初始化]关键字声明  lateinit只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）  延后初始化。只能用于只读变量。   12345678910111213">
<meta name="keywords" content="Kotlin">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin 学习记录">
<meta property="og:url" content="http://maplestory.work/2019/07/15/2019-07-15- Kotlin 学习记录/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Kotlin 学习记录   本文只记录重要的或者与C/C++、Java 出入较大的内容，或者我未习得的知识点Kotlin 变、常量用法 在类中定义变量必须初始化，暂时不能初始化的可用lateinit[后期初始化]关键字声明  lateinit只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）  延后初始化。只能用于只读变量。   12345678910111213">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-08-22T01:28:52.911Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kotlin 学习记录">
<meta name="twitter:description" content="Kotlin 学习记录   本文只记录重要的或者与C/C++、Java 出入较大的内容，或者我未习得的知识点Kotlin 变、常量用法 在类中定义变量必须初始化，暂时不能初始化的可用lateinit[后期初始化]关键字声明  lateinit只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）  延后初始化。只能用于只读变量。   12345678910111213">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://maplestory.work"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019-07-15- Kotlin 学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/2019-07-15- Kotlin 学习记录/" class="article-date">
  <time datetime="2019-07-14T16:00:00.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Kotlin 学习记录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <center><h2><b> Kotlin 学习记录 </b></h2></center><br>

<pre><code>本文只记录重要的或者与C/C++、Java 出入较大的内容，或者我未习得的知识点</code></pre><h2 id="Kotlin-变、常量用法"><a href="#Kotlin-变、常量用法" class="headerlink" title="Kotlin 变、常量用法"></a>Kotlin 变、常量用法</h2><ol>
<li><p>在类中定义变量必须初始化，暂时不能初始化的可用<strong>lateinit</strong>[后期初始化]关键字声明</p>
</li>
<li><p><strong>lateinit</strong>只能声明于 var 变量（不能为可空变量、不能为基本数据类型、使用变量前必须赋值）</p>
</li>
<li><p>延后初始化。只能用于只读变量。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个延迟初始化的字符串数组变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mTitles : Array&lt;String&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">arrayOf(</span><br><span class="line">        ctx.getString(R.string.tab_title_android),</span><br><span class="line">        ctx.getString(R.string.tab_title_ios),</span><br><span class="line">        ctx.getString(R.string.tab_title_h5)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个延迟初始化的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mStr : String <span class="keyword">by</span> lazy&#123;</span><br><span class="line"><span class="string">"我是延迟初始化字符串变量"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>val 不是常量，是不可修改的变量。常量为 const val 且 const 不能用于修饰var</p>
</li>
<li><p>常量声明的三种正确方式</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 顶层声明</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> NUM_A : String = <span class="string">"顶层声明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在object修饰的类中</span></span><br><span class="line"><span class="keyword">object</span> TestConst&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> NUM_B = <span class="string">"object修饰的类中"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 伴生对象中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NUM_C = <span class="string">"伴生对象中声明"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"NUM_A =&gt; <span class="variable">$NUM_A</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_B =&gt; <span class="subst">$&#123;TestConst.NUM_B&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"NUM_C =&gt; <span class="subst">$&#123;TestClass.NUM_C&#125;</span>"</span>)</span><br><span class="line">&#125;常量声明的三种正确方式</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>Kotlin当中不支持8进制</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num16 = <span class="number">0x0F</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">0b11110001</span></span><br><span class="line"><span class="keyword">var</span> num10 = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Kotlin中可以通过下划线作数值中的逗号</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line">println(<span class="string">"var oneMillion = 1_000_000 =&gt; var oneMillion = <span class="variable">$oneMillion</span>"</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>数值比较：== 比较值，===比较内存中的地址</p>
</li>
<li><p>位运算大有不同：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> operaNum = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shlnum = operaNum shl(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> shrnum = operaNum shr(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> ushrnum = operaNum ushr(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">" shlOperaNum =&gt; <span class="variable">$shlnum</span> \n"</span> +</span><br><span class="line">        <span class="string">" shrOperaNum =&gt; <span class="variable">$shrnum</span> \n"</span> +</span><br><span class="line">        <span class="string">" ushrOperaNum =&gt; <span class="variable">$ushrnum</span> \n "</span> )</span><br></pre></td></tr></table></figure>

<p>​    <code>Kotlin</code>中对于按位操作，和Java是有很大的差别的。<code>Kotlin</code>中没有特殊的字符，但是只能命名为可以以中缀形式调用的函数，下列是按位操作的完整列表(仅适用于整形（<code>Int</code>）和长整形（<code>Long</code>）)：</p>
<blockquote>
<ul>
<li><p><code>shl(bits)</code> =&gt; 有符号向左移 (类似<code>Java</code>的<code>&lt;&lt;</code>)</p>
</li>
<li><p><code>shr(bits)</code> =&gt; 有符号向右移 (类似<code>Java</code>的<code>&gt;&gt;</code>)</p>
</li>
<li><p><code>ushr(bits)</code> =&gt; 无符号向右移 (类似<code>Java</code>的<code>&gt;&gt;&gt;</code>)</p>
</li>
<li><p><code>and(bits)</code> =&gt; 位运算符 <code>and</code> (同<code>Java</code>中的按位与)</p>
</li>
<li><p><code>or(bits)</code> =&gt; 位运算符 <code>or</code> (同<code>Java</code>中的按位或)</p>
</li>
<li><p><code>xor(bits)</code> =&gt; 位运算符 <code>xor</code> (同<code>Java</code>中的按位异或)</p>
</li>
<li><p><code>inv()</code> =&gt; 位运算符 按位取反 (同<code>Java</code>中的按位取反)</p>
</li>
</ul>
</blockquote>
<ol start="5">
<li>数组分 <code>arrayOf()</code>, <code>arrayOfNulls()</code>, <code>Array()</code>, <code>原始类型数组</code></li>
</ol>
<h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><ol>
<li><code>IF</code></li>
</ol>
<p>​       需要注意，Kotlin中没有三元运算符 <code>:?</code>, 因为<code>if</code>表达式会有返回值，当条件内逻辑为代码段时，则选择最后一句的值作为返回值。</p>
<ol start="2">
<li><code>FOR</code></li>
</ol>
<p>​       Kotlin中不再有 <code>for(int i=0;i&lt;n;++i)</code> 这种语法。</p>
<blockquote>
<ul>
<li>关键字 until</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">5</span>)&#123;</span><br><span class="line">&gt; print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>) <span class="comment">//until[0,5)</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>关键词downTo</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 	<span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">15</span> downTo <span class="number">0</span>)&#123;</span><br><span class="line">&gt; 	print(<span class="string">"i=&gt; <span class="variable">$i</span> \t"</span>) <span class="comment">//downTo[15-&gt;0]</span></span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>关键符号“..”</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; print(<span class="string">"使用 符号`..`的打印结果\n"</span>)</span><br><span class="line">&gt; <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">20</span> .. <span class="number">25</span>)&#123;</span><br><span class="line">&gt;   print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; println() <span class="comment">//输出结果为 	i=&gt;20 i=&gt;21 i=&gt;22 i=&gt;23 i=&gt;24 i=&gt;25	</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>设置步长</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">10</span> until <span class="number">16</span> step <span class="number">2</span>)&#123;</span><br><span class="line">&gt;   print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)  <span class="comment">//输出10，12，14</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>迭代</li>
</ul>
<blockquote>
<p>提供一个迭代器来遍历任何东西；数组被编译为一个基于索引的循环，<strong>他不会创建一个迭代器对象</strong></p>
</blockquote>
<ul>
<li><p>遍历字符串</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="string">"abcdefg"</span>)&#123;</span><br><span class="line">&gt;   	print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>遍历数组</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">var</span> arrayListOne = arrayOf(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>)</span><br><span class="line">&gt;    <span class="keyword">for</span> (i <span class="keyword">in</span> arrayListOne)&#123;</span><br><span class="line">&gt;        print(<span class="string">"i =&gt; <span class="variable">$i</span> \t"</span>)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用indices遍历数组</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> arrayListTwo = arrayOf(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>)</span><br><span class="line">&gt;  <span class="keyword">for</span> (i <span class="keyword">in</span> arrayListTwo.indices)&#123;</span><br><span class="line">&gt; 	println(<span class="string">"arrayListTwo[<span class="variable">$i</span>] =&gt; "</span> + arrayListTwo[i])</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用withIndex()遍历数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    var arrayListTwo = arrayOf(1,3,5,7,9)</span><br><span class="line">&gt;    for ((index,value) in arrayListTwo.withIndex())&#123;</span><br><span class="line">&gt;        println(&quot;index =&gt; $index \t value =&gt; $value&quot;)</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li>使用列表或数组的扩展函数遍历</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">var</span> arrayListThree = arrayOf(<span class="number">2</span>,<span class="string">'a'</span>,<span class="number">3</span>,<span class="literal">false</span>,<span class="number">9</span>)</span><br><span class="line">&gt;   <span class="keyword">var</span> iterator: Iterator&lt;Any&gt; = arrayListThree.iterator()</span><br><span class="line">&gt;    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">&gt;        println(iterator.next())</span><br><span class="line">&gt;    &#125;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>//需要学习 Kotlin中的 it关键字 / Array函数本质 / lamda表达 / 函数定义</p>
</blockquote>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><ol>
<li><p>语法</p>
<p>无参数的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fun1 = &#123;<span class="number">9</span>&#125; <span class="comment">//定义了一个返回了Int的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该定义参照了情况3</span></span><br><span class="line"><span class="comment">//传入一个Lambda来表示的形式参数，该形参为一个无参返回Int的函数</span></span><br><span class="line"><span class="keyword">var</span> fun11 : (()-&gt;(<span class="built_in">Int</span>)) -&gt;<span class="built_in">Int</span> = &#123;initfunc -&gt; initfunc()&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value00 = fun11(fun1)</span><br><span class="line">println(<span class="string">"value00 =&gt; <span class="variable">$value00</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>有参数的情况</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value1 = <span class="number">9</span></span><br><span class="line"><span class="keyword">val</span> fun2:(<span class="built_in">Int</span>,<span class="built_in">Int</span>)-&gt;<span class="built_in">Double</span> = &#123;a,b-&gt; (a-b).toDouble()&#125;</span><br><span class="line"><span class="keyword">var</span> value2 = fun2(value1,<span class="number">3</span>)</span><br><span class="line">println(<span class="string">"value2 =&gt; <span class="variable">$value2</span>"</span>)<span class="comment">//输出：value2 =&gt; 6.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式如下</span></span><br><span class="line"><span class="keyword">var</span> fun3 = &#123;a:<span class="built_in">Int</span>,b:<span class="built_in">Int</span> -&gt; a+b&#125;</span><br><span class="line"><span class="keyword">var</span> value3 = fun3(<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"value3 =&gt; <span class="variable">$value3</span>"</span>)<span class="comment">//输出：value3 =&gt; 9</span></span><br><span class="line"><span class="comment">//3. lambda表达式作为函数中的参数的时候，这里举一个例子：</span></span><br><span class="line"><span class="comment">//  fun test(a : Int, 参数名 : (参数1 ： 类型，参数2 : 类型, ... ) -&gt; 表达式返	 //回类型)&#123;</span></span><br><span class="line"><span class="comment">//     ...</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个新形式都可以作为value计算的表达式，fun与var功能似乎一样了？NO</span></span><br><span class="line"><span class="comment">//三种形式定义该test函数，fun声明，var声明，匿名函数。</span></span><br><span class="line"><span class="comment">//fun test(a:Int,b:Int,add:(Int,Int)-&gt;Int):Int&#123; return add(a,b)&#125;//是一个函数</span></span><br><span class="line"><span class="comment">//var test: (Int,Int,(Int,Int)-&gt;Int) -&gt; Int = &#123;a,b,add -&gt; add(a,b)&#125;//该变量是lambda变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="title">fun</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,add:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123; <span class="keyword">return</span> add(a,b)&#125; <span class="comment">//是一个函数</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"value4 = <span class="variable">$value4</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>​        <code>lambda</code>表达式总是被大括号括着</p>
<p>​        定义完整的<code>Lambda</code>表达式如上面实例中的语法2，它有其完整的参数类型标注，与表达式返回值。当我们把一些类型标注省略的情况下，就如上面实例中的语法2的另外一种类型。当它推断出的返回值类型不为<code>Unit</code>时，它的返回值即为-&gt;符号后代码段中的最后一个表达式的类型（如同if-else语句块中的返回值一样）</p>
<p>​        当函数的参数仅有一个Lambda表达式的时候可以<strong>省略参数的那个小括号</strong></p>
</li>
<li><p>it</p>
<ul>
<li>it不是关键字</li>
<li>it在高阶函数中的lambda表达式的参数只有一个的时候可以使用<code>it</code>来使用此参数。<code>it</code>可表示<strong>单个参数的隐式名称</strong></li>
</ul>
<p>例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(num1 : <span class="type">Int</span>, bool : (<span class="type">Int</span>) -&gt; <span class="type">Boolean</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">if</span> (bool(num1))&#123; num1 &#125; <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(test(<span class="number">10</span>,&#123;it &gt; <span class="number">5</span>&#125;)) <span class="comment">// &#123;&#125; 代表这是一个Lambda表达式，无&#123;&#125;会使得编译器不认识it</span></span><br><span class="line">println(test(<span class="number">4</span>,&#123;it &gt; <span class="number">5</span>&#125;))</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>_</p>
<p>在使用<code>Lambda</code>表达式的时候，可以用下划线表示未使用的参数，表示不处理这个参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf&lt;String,String&gt;(<span class="string">"key1"</span> to <span class="string">"value1"</span>,<span class="string">"key2"</span> to  <span class="string">"value2"</span>,<span class="string">"key3"</span> to  <span class="string">"value3"</span>)</span><br><span class="line"></span><br><span class="line">map.forEach&#123;</span><br><span class="line">    key,value -&gt; println(<span class="string">"<span class="variable">$key</span> '-' <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">map.forEach&#123;</span><br><span class="line">        _,value -&gt; println(<span class="string">" '-' <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>匿名函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> test1 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> = x+y; <span class="comment">//单表达式函数可以 = 替换 &#123;&#125;</span></span><br><span class="line"><span class="keyword">val</span> test2 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>= x+y;</span><br><span class="line"><span class="keyword">val</span> test3 = <span class="function"><span class="title">fun</span> <span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">println(test1(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">println(test2(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">println(test3(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">//这是错的，fun的需要返回值为Unit，但你给了个Int</span></span><br><span class="line"><span class="comment">    val test4= fun(x:Int,y:Int) &#123;</span></span><br><span class="line"><span class="comment">        return x+y</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>带接收者的函数字面值</p>
<ol start="6">
<li><p>匿名函数作为接收者类型</p>
<p>匿名函数语法允许直接指定函数字面值的接收者类型，如果你需要使用带接收者的函数类型声明一个变量。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iop = <span class="function"><span class="keyword">fun</span>  <span class="built_in">Int</span>.<span class="params">(other:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span> = <span class="keyword">this</span> + other</span><br><span class="line">println(<span class="number">20</span>.iop(<span class="number">2</span>)) <span class="comment">//上面的this指的是左边的20 或者是 上面fun后的第一个Int</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="2">
<li><p>Lambda表达式作为接收者类型</p>
<p>要用Lambda表达式作为接收者类型的前提是**接收着类型可以从上下文中推断出来</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTML</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">body</span><span class="params">()</span></span>&#123;</span><br><span class="line">		println(<span class="string">"This is HTML body"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span>  <span class="title">html</span><span class="params">(<span class="keyword">init</span>: <span class="type">HTML</span>.() -&gt; <span class="type">Unit</span>)</span></span>: HTML&#123;</span><br><span class="line">	<span class="keyword">val</span> html = HTML()</span><br><span class="line">	html.<span class="keyword">init</span>()</span><br><span class="line">	<span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#123;</span><br><span class="line">	body()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<ol start="6">
<li><p>闭包</p>
<p>闭包，可以函数中包含函数。</p>
<ul>
<li>携带状态</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">让函数返回一个函数，并携带状态值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test5</span><span class="params">(a:<span class="type">Int</span>)</span></span>:()-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">    println(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        println(<span class="string">"b=&gt; <span class="variable">$b</span>"</span>)</span><br><span class="line">        b++</span><br><span class="line">        <span class="keyword">return</span> b + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = test5(<span class="number">3</span>)</span><br><span class="line">println(t()) <span class="comment">// 每次执行t函数的时候，b变量的值都是保留了上次执行结束的值，</span></span><br><span class="line">			 <span class="comment">// 因此，叫做携带状态值</span></span><br><span class="line">println(t())</span><br><span class="line">println(t())</span><br></pre></td></tr></table></figure>

<ul>
<li>引用外部变量，并改变外部变量的值</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">arr.filter &#123; it&lt;<span class="number">7</span> &#125;.forEach&#123;sum += it&#125;</span><br><span class="line"><span class="comment">//arr.filter &#123; it&lt;7 &#125;.forEach (&#123;sum += it&#125;)</span></span><br><span class="line"></span><br><span class="line">println(sum)</span><br></pre></td></tr></table></figure>

<h2 id="可空类型、空安全、非空断言"><a href="#可空类型、空安全、非空断言" class="headerlink" title="可空类型、空安全、非空断言"></a>可空类型、空安全、非空断言</h2><ol>
<li><p>判空的方法，if-else / ?. 判断</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str : String? = <span class="string">"12346"</span></span><br><span class="line">str = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">println(str?.length) <span class="comment">//输出null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个函数/方法有返回值时，如果方法中的代码使用<code>?.</code>去返回一个值，那么方法的返回值的类型后面也要加上<code>?</code>符号</p>
</li>
<li><p>let操作符</p>
<p>let操作符作用：当使用?.符号时验证时忽略掉null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">val arrTest : Array&lt;Int?&gt; = arrayOf(1,2,null,3,null,5,6,null)</span><br><span class="line"></span><br><span class="line">// 传统写法</span><br><span class="line">for (index in arrTest) &#123;</span><br><span class="line">    if (index == null)&#123;</span><br><span class="line">        continue</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;index =&gt; $index&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// let写法</span><br><span class="line">for (index in arrTest) &#123;</span><br><span class="line">    index?.let &#123; println(&quot;index =&gt; $it&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    index =&gt; 1</span><br><span class="line">    index =&gt; 2</span><br><span class="line">    index =&gt; 3</span><br><span class="line">    index =&gt; 5</span><br><span class="line">    index =&gt; 6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>Evils操作符</p>
<p>安全性操作符有三种：<code>?:</code> /<code>!!</code> / <code>as?</code></p>
<p><code>?:</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> testStr : String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例： 当testStr不为空时，输出其长度，反之输出-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">length = <span class="keyword">if</span> (testStr != <span class="literal">null</span>) testStr.length <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 写法</span></span><br><span class="line">length = testStr?.length ?: -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">println(length)</span><br></pre></td></tr></table></figure>

<p><code>!!</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val testStr : String? = null</span><br><span class="line">println(testStr!!.length)</span><br><span class="line">//如果变量为空，使用!!修饰，运行时会抛出空指针异常</span><br></pre></td></tr></table></figure>

<p><code>as</code></p>
<p>使用<code>as</code>进行强制转换，在不能转换时会抛出异常，而使用<code>as?</code>则会返回<code>null</code>，但不会抛出异常。</p>
</li>
</ol>
<h2 id="Kotlin-函数"><a href="#Kotlin-函数" class="headerlink" title="Kotlin 函数"></a>Kotlin 函数</h2><ol>
<li><p>默认参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">defArgs</span><span class="params">(numA : <span class="type">Int</span>  = <span class="number">1</span>, numB : <span class="type">Float</span> = <span class="number">2</span>f, numC : <span class="type">Boolean</span> = <span class="literal">false</span>)</span></span>&#123;</span><br><span class="line">    println(<span class="string">"numA  =  <span class="variable">$numA</span> \t numB = <span class="variable">$numB</span> \t numC = <span class="variable">$numC</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认参数的函数使用</span></span><br><span class="line">    defArgs()</span><br><span class="line">    defArgs(<span class="number">1</span>,<span class="number">10f</span>,<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>命名参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callFun(<span class="string">"str"</span>,isTrue = <span class="literal">true</span>,numA = <span class="number">3</span>) <span class="comment">//java中不支持这么写</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>可变参数</p>
<p>​    当一个函数中的参数是不定数量的个数并且是同一个类型，则可是使用<code>vararg</code>修饰符去修饰这个变量，则被<code>vararg</code>修饰的参数相当于一个固定类型的数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">varargFun</span><span class="params">(numA: <span class="type">Int</span>, <span class="keyword">vararg</span> str : <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (s <span class="keyword">in</span> str) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="comment">//    str[index]</span></span><br><span class="line"><span class="comment">//    str.component1() ... str.component5()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者其高阶函数用法</span></span><br><span class="line"><span class="comment">//    str.map &#123;  &#125;</span></span><br><span class="line"><span class="comment">//    str.filter &#123;  &#125;</span></span><br><span class="line"><span class="comment">//    str.sortBy &#123;  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">普通传递 : varargFun(1,"aaa","bbb","ccc","ddd","fff")</span></span><br><span class="line"><span class="comment">数组传递：</span></span><br><span class="line"><span class="comment">        val strArray = arrayOf("aaa","bbb","ccc","ddd","fff")</span></span><br><span class="line"><span class="comment">        varargFun(1,*strArray) // *叫做伸展操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>单表达式函数</p>
<p>​    函数具备返回值的时候，可以省略花括号并且在<code>=</code>赋值符号之后指定代码体，而函数的返回值是有编辑器自动推断的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">()</span></span> = <span class="number">2</span>                     <span class="comment">// 自动推断为：返回类型为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">(num : <span class="type">Int</span>)</span></span> = num * <span class="number">2</span>      <span class="comment">// 自动推断为：返回类型为Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test3</span><span class="params">(x : <span class="type">Float</span>, y : <span class="type">Int</span> = <span class="number">2</span>)</span></span> = x * y  <span class="comment">// 和默认参数一起使用，返回值为Float型</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ol>
<li><p>当类没有结构体时可以省略大括号：<code>class Test</code></p>
</li>
<li><p>主构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">constructor</span></span>(num :<span class="built_in">Int</span>)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>(num:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>初始化代码块</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">constructor</span></span>(<span class="keyword">var</span> num:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">init</span>&#123;</span><br><span class="line">     	num = <span class="number">5</span></span><br><span class="line">        println(<span class="string">"num = <span class="variable">$num</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>如上，声明属性可以直接在类头声明</p>
</li>
<li><p>当构造函数不具有注释符或者使用默认的可见性修饰符时，可以省略constructor关键字</p>
</li>
<li><p>辅助构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    constructor(参数)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>同时存在主构造函数和二级构造函数</p>
<p>​    如果类具有主构造函数，则每个辅助构造函数需要通过另一个辅助构造函数直接或间接地委派给主构造函数。 使用<code>this</code>关键字对同一类的另一个构造函数进行委派：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class_example2</span> <span class="keyword">constructor</span></span>( num1:<span class="built_in">Int</span> = <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> num2 :<span class="built_in">Int</span> = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(num1)</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>( num1:<span class="built_in">Int</span> = <span class="number">2</span>, num3:<span class="built_in">Int</span>):<span class="keyword">this</span>(num1)&#123;</span><br><span class="line">        println(<span class="string">"num3+num1 = <span class="variable">$num1</span> + <span class="variable">$num3</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//虽然这里写的是num3，但其实调用的是主构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(num1: <span class="built_in">Int</span> = <span class="number">2</span>,num3: <span class="built_in">Int</span>,num2:<span class="built_in">Int</span>):<span class="keyword">this</span>(num3)&#123; </span><br><span class="line">        println(<span class="string">"constructor - 3 para"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c :Class_example2 = Class_example2( <span class="number">3</span>,num3 = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> cc:Class_example2 = Class_example2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">num3+num1 = 3 + 3</span></span><br><span class="line"><span class="comment">2      </span></span><br><span class="line"><span class="comment">constructor - 3 para</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>当类的主构造函数都存在默认值的情况下</p>
<ul>
<li>在<code>JVM</code>上，如果类主构造函数的所有参数都具有默认值，编译器将生成一个额外的无参数构造函数，它将使用默认值。 这使得更容易使用<code>Kotlin</code>与诸如<code>Jackson</code>或<code>JPA</code>的库，通过无参数构造函数创建类实例。</li>
<li>同理可看出，当类存在主构造函数并且有默认值时，二级构造函数也适用</li>
<li>如果第一个第一个参数不是默认的，则不会有无参的，可以调用一个参数的。</li>
<li>总结：如果中间有不具备默认参数的，则到该参数为止都需要进行强制给值，直到参数赋值完或者后面的都是由默认值的形参。</li>
</ul>
</li>
<li><p>类的实例化</p>
<p>没有 <code>new</code> 关键字。</p>
</li>
<li><p>类的类别</p>
<p>密封类、内部类、抽象类、枚举类、接口类、数据类</p>
</li>
</ol>
<h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><ol>
<li><p>Getter &amp; Setter</p>
<pre><code>1. 在Kotlin中，想要外部变量不能访问某类内的变量则将Setter进行private修饰，若使用private修饰属性则该变量不能对该属性进行访问
 2. val属性不能有setter函数
 3. getter一般写，默认实现。写了 get()=&quot;修改也不变&quot;,则当前属性值永远为“修改也不变”</code></pre></li>
<li><p>修改访问器（Getter/Setter）的可见性</p>
<ol>
<li>get函数前面的可见性修饰符需要和属性一直</li>
<li>可以用@Inject set 来对实现<code>Setter</code></li>
<li>共有属性var，setter用private进行修饰，则表示该属性不能外部修改值。</li>
</ol>
</li>
<li><p>后备字段 <a href="https://stackoverflow.com/questions/43220140/whats-kotlin-backing-field-for" target="_blank" rel="noopener">(What is backing field)</a></p>
<ol>
<li><p>定义：如果属性使用至少一个访问器的<strong>默认实现</strong>，或者<strong>自定义访问通过field标识符引用</strong>，则将为属性生成后备字段。 （换句话，如果没有默认访问器实现 &amp;&amp; 没有自定义通过访问field标识符进行引用，则不会有后备字段）</p>
</li>
<li><p>原理：Kotlin中没有字段，但有后备字段。在isEmpty例子中可以学习到，判断类中是否为空不需要单独的字段，只需要对size进行判断即可，因此该变量不需要字段。而size则需要后备字段。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> isEmpty <span class="comment">//no backing field</span></span><br><span class="line">        <span class="keyword">get</span>() = size == <span class="number">0</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            size = size * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DummyClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.size = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.size == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setEmpty</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.size *= <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>后备属性</p>
<p>_table是private 没有法访问，定义了table属性来对 _table进行get操作。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _table: Map&lt;String, <span class="built_in">Int</span>&gt;? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> table: Map&lt;String, <span class="built_in">Int</span>&gt;  <span class="comment">/// table就是后备属性。</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_table == <span class="literal">null</span>) &#123;</span><br><span class="line">            _table = HashMap() <span class="comment">// 初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ?: 操作符，如果_table不为空则返回，反之则抛出AssertionError异常</span></span><br><span class="line">        <span class="keyword">return</span> _table ?: <span class="keyword">throw</span> AssertionError(<span class="string">"Set to null by another thread"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>编译时常数</p>
<p>编译时常数必须为顶层声明，初始化为<code>String</code>或者基本类型，没有自定义的getter()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CONST_NUM = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> CONST_STR = <span class="string">"Kotlin"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后期初始化属性</p>
<p>只能用于修饰var，没有自定义的setter与getter函数，属性必须为空且类型不能为基本类型。</p>
</li>
<li><p>委托属性</p>
</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>public、internal、protected、private</p>
<ol>
<li><p>顶层声明</p>
<ol>
<li>在顶层声明中，文件不能用protected修饰</li>
<li>不同文件中，访问顶层声明的可以访问，public和internal</li>
</ol>
</li>
<li><p>在类中声明</p>
<ol>
<li>类中可以使用任意修饰符，且类内可以任意访问</li>
<li>类外的函数，只能访问public和internal</li>
</ol>
</li>
<li><p>在接口中声明</p>
<ol>
<li>只能声明public属性。</li>
<li>修饰private类和private的方法</li>
<li>用private修饰的方法不能被实现该接口的类重载。</li>
</ol>
</li>
<li><p>在构造函数中的声明</p>
<ol>
<li>任意使用修饰符</li>
<li>在二级构造函数中，不能用任意修饰符，可以说是默认修饰（public）</li>
</ol>
</li>
<li><p>在局部声明中同上步中的二级构造函数</p>
</li>
<li><p>与Java中的对比</p>
<p>四个修饰符不同、默认修饰符不同</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>超类（Any）；用：符号继承</p>
</li>
<li><p>open修饰符</p>
<ol>
<li>open修饰符是定义继承类的修饰符</li>
<li>类和成员都需要使用open关键字</li>
</ol>
</li>
<li><p>继承类的构造函数</p>
<ol>
<li><p>实现类无主构造函数</p>
<p>每个辅助构造函数必须使用<code>super</code>关键字初始化或者委托给另一个构造函数。</p>
</li>
<li><p>存在主构造函数</p>
<p>主构造函数一般实现基类中参数最多的构造函数，参数少的哦那个this引用即可。</p>
</li>
</ol>
</li>
<li><p>函数的重写</p>
<ol>
<li><p>子类不能重写基类中没有用open修饰的同名函数。</p>
</li>
<li><p>当一个类不是用open修饰时，该类默认实final，不能被再次继承</p>
</li>
<li><p>子类用final关键字修饰方法，以此来禁止后续子类重写该方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B这个类继承类A，并且类B同样使用open修饰符修饰了的</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 这里使用final修饰符修饰该方法，禁止覆盖掉类A的foo()函数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<ol start="5">
<li><p>重写属性</p>
<ol>
<li><p>重写属性必须用override修饰。</p>
</li>
<li><p>当基类属性修饰为val时，实现类可以用var去重写，反之却不行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> valStr = <span class="string">"我是用val修饰的属性"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里用val、或者var重写都是可以的。</span></span><br><span class="line"><span class="comment">     * 不过当用val修饰的时候不能有setter()函数，编辑器直接会报红的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// override val valStr: String</span></span><br><span class="line">    <span class="comment">//   get() = super.valStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// override var valStr: String = ""</span></span><br><span class="line">    <span class="comment">//   get() = super.valStr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// override val valStr: String = ""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> valStr: String = <span class="string">"abc"</span></span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arge: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">    println(DemoTest().valStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo = DemoTest()</span><br><span class="line">    demo.valStr = <span class="string">"1212121212"</span></span><br><span class="line">    println(demo.valStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写属性是不能用 get() = super.xxx，因为这样的话，不管你是否重新为该属性赋了新值，还是支持<code>setter()</code>,在使用的时候都调用的是基类中的属性值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> : <span class="type">Demo</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里介绍重写属性是，getter()函数中使用`super`关键字的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> valStr: String = <span class="string">"abc"</span>、</span><br><span class="line">        <span class="keyword">get</span>() = <span class="keyword">super</span>.valStr</span><br><span class="line">        <span class="keyword">set</span>(value)&#123;field = value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arge: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;&gt;)</span></span>&#123;</span><br><span class="line">    println(DemoTest().valStr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> demo = DemoTest()</span><br><span class="line">    demo.valStr = <span class="string">"1212121212"</span></span><br><span class="line">    println(demo.valStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也不能 get() = this.valStr / get() = valStr 。会报运行错误。</p>
<p>Exception：StackOverflowError</p>
<p>java.lang.StackOverflowError:stacksize8MBStackOverflowError是由于当前线程的栈满了,也就是函数调用层级过多导致。堆栈溢出错误一般是递归调用。出现这种异常,大多是由于循环调用。出现的情况:大多数都是在本方法中调用本方法。也就是我们常说的递归调用,所以才导致这个错误的出现。</p>
<p>应该用默认的 get() = field</p>
</li>
</ol>
</li>
<li><p>在主构造函数重写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest2</span></span>(<span class="keyword">override</span> <span class="keyword">var</span> num: <span class="built_in">Int</span>, <span class="keyword">override</span> <span class="keyword">val</span> valStr: String) : Demo()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> demo2 = DemoTest2(<span class="number">1</span>,<span class="string">"构造函数中重写"</span>)</span><br><span class="line">    println(<span class="string">"num = <span class="subst">$&#123;demo2.num&#125;</span> \t valStr = <span class="subst">$&#123;demo2.valStr&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>覆盖规则:解决两个接口方法名相同问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">open class A&#123;</span><br><span class="line">    open fun test1()&#123; println(&quot;基类A中的函数test1()&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    open fun test2()&#123;println(&quot;基类A中的函数test2()&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface B&#123;</span><br><span class="line">    fun test1()&#123; println(&quot;接口类B中的函数test1()&quot;) &#125;</span><br><span class="line"></span><br><span class="line">    fun test2()&#123;println(&quot;接口类B中的函数test2()&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C : A(),B&#123;</span><br><span class="line">    override fun test1() &#123;</span><br><span class="line">        super&lt;A&gt;.test1()</span><br><span class="line">        super&lt;B&gt;.test1()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun test2() &#123;</span><br><span class="line">        super&lt;A&gt;.test2()</span><br><span class="line">        super&lt;B&gt;.test2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="接口类-枚举类"><a href="#接口类-枚举类" class="headerlink" title="接口类/枚举类"></a>接口类/枚举类</h2><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ol>
<li><p>枚举类的初始化及使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum class Color(var argb : String)&#123;</span><br><span class="line">    RED(&quot;&quot;),</span><br><span class="line">    WHITE(&quot;&quot;),</span><br><span class="line">    BLACK(&quot;&quot;),</span><br><span class="line">    GREEN(&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量，枚举类中的每个枚举常量都是对象，用逗号分隔。（如上述的RED(“”),）</p>
<p>直接用<code>Color.RED</code>进行访问。</p>
</li>
<li><p>枚举常量匿名类，必须提供一个抽象方法，且该方法定义在枚举类内部。而且必须在枚举变量的后面，有抽象函数，则最后一个枚举变量必须用<code>;</code>隔开。</p>
</li>
<li><p>枚举常量的属性：name（常量名）和ordinal（常量位置）</p>
</li>
<li><p>可以用<code>enumValues&lt;T&gt;()</code> 和<code>enumValuesOf&lt;T&gt;()</code>访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(enumValues&lt;Color&gt;().joinToString &#123; it.name &#125;)</span><br><span class="line">println(enumValueOf&lt;Color&gt;(&quot;RED&quot;))</span><br><span class="line"></span><br><span class="line">//输出</span><br><span class="line">//RED, WHITE, BLACK, GREEN</span><br><span class="line">//RED</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>用 <code>valueof()</code>和<code>values()</code>检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(Color.valueOf(&quot;RED&quot;))</span><br><span class="line">println(Color.values()[0])</span><br><span class="line">println(Color.values()[1])</span><br><span class="line">println(Color.values()[2])</span><br><span class="line">println(Color.values()[3])</span><br></pre></td></tr></table></figure>

<p>其中，若使用<code>Color.valueOf(&quot;不存在的枚举常量&quot;)</code>，则会抛出<code>IllegalArgumentException</code> 异常，即枚举变量不存在。若使用<code>Color.values()[大于枚举常量位置]</code>，则会抛出下标越界异常。</p>
</li>
</ol>
<h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><ol>
<li>用<code>：</code>进行对接口的实现</li>
<li>Kotlin中接口中可以写属性，作为抽象属性、作为访问器</li>
<li>多接口可用<code>super&lt;接口名&gt;.方法名</code>来区分。</li>
</ol>
<h2 id="数据类和密封类"><a href="#数据类和密封类" class="headerlink" title="数据类和密封类"></a>数据类和密封类</h2><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><ol>
<li>关键字<code>data</code></li>
<li>构造函数必须存在至少一个参数。</li>
<li>数据类的特性：<ol>
<li>数据类不能是抽象的、开放的、密封的或者内部的。</li>
<li>数据类可以实现接口，同时也可以继承其他类，如密封类。</li>
</ol>
</li>
</ol>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><ol>
<li>关键字<code>sealed</code></li>
<li>sealed class SealedExpr()</li>
<li>密封类<strong>不能被实例化</strong>，他的作用是<em>表示受限的类继承结构</em></li>
<li>密封类可以有多个实例。</li>
<li>密封类的子类必须是在密封类的内部或必须存在于密封类的同一文件，密封类可以有效地保护代码。</li>
</ol>
<h2 id="抽象类-amp-内部类"><a href="#抽象类-amp-内部类" class="headerlink" title="抽象类&amp;内部类"></a>抽象类&amp;内部类</h2><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol>
<li>抽象类有抽象成员，抽象成员都带<code>abstract</code>关键字</li>
<li>Kotlin中的抽象类，在顶层定义时只能使用<code>public</code></li>
<li>抽象类中可以定义内部抽象类</li>
<li>只能继承一个抽象类</li>
<li>抽象类，可以通过子类向上转型</li>
<li>抽象类可以继承另一个类，但不建议用open修饰抽象类</li>
</ol>
<h4 id="嵌套类类"><a href="#嵌套类类" class="headerlink" title="嵌套类类"></a>嵌套类类</h4><ol>
<li><p>定义：一个类嵌套在另一个类当中</p>
</li>
<li><p><code>外部类.嵌套类().嵌套类方法/属性。在调用的时候嵌套类是需要实例化的</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"test"</span>, <span class="string">"Nested -&gt; execute"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">Outter.Nested().execute()</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Nested -&gt; execute</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><ol>
<li><p>定义：用inner class 来进行声明类</p>
</li>
<li><p>内部类不能直接被实例化，需要外部的类实例化了对象，再利用该对象进行实例化内部类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> testVal = <span class="string">"test"</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">"test"</span>, <span class="string">"Inner -&gt; execute : can read testVal=<span class="variable">$testVal</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">val</span> outter = Outter()</span><br><span class="line">outter.Inner().execute()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Inner -&gt; execute : can read testVal=test</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>监听器的实现方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.zju.maple.learning</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NickInnerClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">private</span> <span class="keyword">var</span> listener:OnClickListener</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: <span class="type">OnClickListener</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = listener</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">activeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        listener.onItemClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> nick = NickInnerClass()</span><br><span class="line">    nick.setOnClickListener(<span class="keyword">object</span>:OnClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemClick</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            println(<span class="string">"执行了activeListener函数，才有这句输出"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">20</span>)&#123;</span><br><span class="line">        i++</span><br><span class="line"></span><br><span class="line">        nick.activeListener() <span class="comment">///唤醒方法</span></span><br><span class="line">        <span class="keyword">for</span> ( temp <span class="keyword">in</span> <span class="number">1</span>..<span class="number">0xFFFF</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<h4 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h4><ol>
<li>局部类只能在定义该局部类的方法中使用</li>
<li>定义在实例方法中的局部类可以访问外部类的所有变量和方法，但不能修改</li>
<li>局部类可以定义属性、方法。</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol>
<li><p>将函数作为参数或者返回值的函数称为高阶函数。</p>
<ol>
<li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///函数作为参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resultByOpt</span><span class="params">(num1 : <span class="type">Int</span> , num2 : <span class="type">Int</span> , result : (<span class="type">Int</span> ,<span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result(num1,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result1 = resultByOpt(<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 + num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result2 = resultByOpt(<span class="number">3</span>,<span class="number">4</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 - num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result3 = resultByOpt(<span class="number">5</span>,<span class="number">6</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 * num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result4 = resultByOpt(<span class="number">6</span>,<span class="number">3</span>)&#123;</span><br><span class="line">        num1, num2 -&gt;  num1 / num2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"result1 = <span class="variable">$result1</span>"</span>)</span><br><span class="line">    println(<span class="string">"result2 = <span class="variable">$result2</span>"</span>)</span><br><span class="line">    println(<span class="string">"result3 = <span class="variable">$result3</span>"</span>)</span><br><span class="line">    println(<span class="string">"result4 = <span class="variable">$result4</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///返回值为函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test5</span><span class="params">(a:<span class="type">Int</span>)</span></span>:()-&gt;<span class="built_in">Int</span>&#123;</span><br><span class="line">    println(<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="title">fun</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">        println(<span class="string">"b=&gt; <span class="variable">$b</span>"</span>)</span><br><span class="line">        b++</span><br><span class="line">        <span class="keyword">return</span> b + a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>常用的标准高阶函数</p>
<ol>
<li><p>TODO函数：将会抛出异常，根据参数的内容输出异常内容</p>
</li>
<li><p>run函数：两种用法</p>
<p>​    当我们需要执行一个<code>代码块</code>的时候就可以用到这个函数,并且这个代码块是独立的。即我可以在<code>run()</code>函数中写一些和项目无关的代码，因为它不会影响项目的正常运行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">testRun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">"kotlin"</span></span><br><span class="line"></span><br><span class="line">    run&#123;</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">"java"</span>   <span class="comment">// 和上面的变量不会冲突</span></span><br><span class="line">        println(<span class="string">"str = <span class="variable">$str</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"str = <span class="variable">$str</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ol>
<pre><code>​    因为`run`函数执行了我传进去的`lambda`表达式并返回了执行的结果，所以当一个业务逻辑都需要执行同一段代码而根据不同的条件去判断得到不同结果的时候。可以用到`run`函数

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> index = <span class="number">3</span></span><br><span class="line"><span class="keyword">val</span> num = run &#123;</span><br><span class="line">    <span class="keyword">when</span>(index)&#123;</span><br><span class="line">        <span class="number">0</span> -&gt; <span class="string">"kotlin"</span></span><br><span class="line">        <span class="number">1</span> -&gt; <span class="string">"java"</span></span><br><span class="line">        <span class="number">2</span> -&gt; <span class="string">"php"</span></span><br><span class="line">        <span class="number">3</span> -&gt; <span class="string">"javaScript"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">"none"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.length</span><br><span class="line">println(<span class="string">"num = <span class="variable">$num</span>"</span>)</span><br></pre></td></tr></table></figure>



​    被一个对象所调用。**当我们传入的lambda表达式想要使用当前对象的上下文的时候，我们可以使用这个函数。**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val str = &quot;kotlin&quot;</span><br><span class="line">str.run &#123;</span><br><span class="line">    println( &quot;length = $&#123;this.length&#125;&quot; )</span><br><span class="line">    println( &quot;first = $&#123;first()&#125;&quot;)</span><br><span class="line">    println( &quot;last = $&#123;last()&#125;&quot; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="3">
<li>同时还有<code>with</code> / <code>let</code> / <code>apply</code> / <code>also</code> / <code>takeIf()</code> / <code>takeUnless</code> / <code>repeat()</code> / <code>lazy()</code> 分别有不同的用法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://maplestory.work/2019/07/15/2019-07-15- Kotlin 学习记录/" data-id="cjzm2ty02001g0gtadj9thtpi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/31/2019-05-31- C# 查看串口/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">C# 查看串口</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/downloader/">downloader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/halve/">halve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jekyll/">jekyll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mcu/">mcu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/parsing-file/">parsing file</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poems/">poems</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sentence/">sentence</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/串口通讯/">串口通讯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 10px;">Algorithm</a> <a href="/tags/C/" style="font-size: 20px;">C#</a> <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/downloader/" style="font-size: 10px;">downloader</a> <a href="/tags/halve/" style="font-size: 10px;">halve</a> <a href="/tags/jekyll/" style="font-size: 10px;">jekyll</a> <a href="/tags/mcu/" style="font-size: 10px;">mcu</a> <a href="/tags/parsing-file/" style="font-size: 10px;">parsing file</a> <a href="/tags/poems/" style="font-size: 13.33px;">poems</a> <a href="/tags/sentence/" style="font-size: 13.33px;">sentence</a> <a href="/tags/串口通讯/" style="font-size: 13.33px;">串口通讯</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/15/2019-07-15- Kotlin 学习记录/">Kotlin 学习记录</a>
          </li>
        
          <li>
            <a href="/2019/05/31/2019-05-31- C# 查看串口/">C# 查看串口</a>
          </li>
        
          <li>
            <a href="/2019/05/30/2019-05-30- C# 监听串口插拔事件/">C# 监听串口插拔事件</a>
          </li>
        
          <li>
            <a href="/2019/05/19/2019-05-19- 设计模式/">设计模式</a>
          </li>
        
          <li>
            <a href="/2019/05/18/2019-05-18- C# 访问UI线程的方法/">C# 访问UI线程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>